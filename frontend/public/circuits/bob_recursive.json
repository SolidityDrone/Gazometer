{"noir_version":"1.0.0-beta.3+ceaa1986628197bd1170147f6a07f0f98d21030a","hash":4204351364394165314,"abi":{"parameters":[{"name":"verification_key","type":{"kind":"array","length":128,"type":{"kind":"field"}},"visibility":"private"},{"name":"proof","type":{"kind":"array","length":456,"type":{"kind":"field"}},"visibility":"private"},{"name":"public_inputs","type":{"kind":"array","length":8,"type":{"kind":"field"}},"visibility":"private"},{"name":"key_hash","type":{"kind":"field"},"visibility":"private"},{"name":"bob_signature_nonce_1","type":{"kind":"array","length":65,"type":{"kind":"integer","sign":"unsigned","width":8}},"visibility":"private"},{"name":"bob_signature_nonce_2","type":{"kind":"array","length":65,"type":{"kind":"integer","sign":"unsigned","width":8}},"visibility":"private"},{"name":"chain_id","type":{"kind":"field"},"visibility":"public"},{"name":"block_number","type":{"kind":"integer","sign":"unsigned","width":64},"visibility":"private"},{"name":"message_nonce_1","type":{"kind":"integer","sign":"unsigned","width":64},"visibility":"private"},{"name":"pub_x_1","type":{"kind":"array","length":32,"type":{"kind":"integer","sign":"unsigned","width":8}},"visibility":"private"},{"name":"pub_y_1","type":{"kind":"array","length":32,"type":{"kind":"integer","sign":"unsigned","width":8}},"visibility":"private"},{"name":"pub_x_2","type":{"kind":"array","length":32,"type":{"kind":"integer","sign":"unsigned","width":8}},"visibility":"private"},{"name":"pub_y_2","type":{"kind":"array","length":32,"type":{"kind":"integer","sign":"unsigned","width":8}},"visibility":"private"},{"name":"contract_address","type":{"kind":"array","length":20,"type":{"kind":"integer","sign":"unsigned","width":8}},"visibility":"private"}],"return_type":{"abi_type":{"kind":"tuple","fields":[{"kind":"field"},{"kind":"field"},{"kind":"field"},{"kind":"field"},{"kind":"field"},{"kind":"field"},{"kind":"field"},{"kind":"field"}]},"visibility":"public"},"error_types":{"292786241566106125":{"error_kind":"fmtstring","length":31,"item_types":[{"kind":"string","length":17}]},"662911055836379074":{"error_kind":"string","string":"Cannot pop array: fragment is too short"},"808102636936227868":{"error_kind":"string","string":"Cannot push: fragment is full"},"1257039332889662951":{"error_kind":"string","string":"Unsupported chain ID"},"1702844987497767662":{"error_kind":"string","string":"number of header RLP fields does not match"},"1784090300352196074":{"error_kind":"string","string":"New max length is smaller than fragment length"},"1797804167342671480":{"error_kind":"string","string":"Invalid node type"},"1848132903095460097":{"error_kind":"string","string":"Expected RLP header to be maximum 1 byte long"},"1975296384129351436":{"error_kind":"string","string":"Decoded length of long string exceeds input length"},"2294458973011079183":{"error_kind":"string","string":"Expected a list"},"2446709291901099778":{"error_kind":"fmtstring","length":31,"item_types":[{"kind":"string","length":12}]},"2814641233417603000":{"error_kind":"fmtstring","length":32,"item_types":[{"kind":"string","length":12}]},"2920182694213909827":{"error_kind":"string","string":"attempt to subtract with overflow"},"3492945213712566949":{"error_kind":"string","string":"Subarray index out of bound"},"3649116680727309155":{"error_kind":"string","string":"Expected to consume all key nibbles"},"3990714964858224170":{"error_kind":"string","string":"Value length mismatch"},"4649481178424447293":{"error_kind":"fmtstring","length":31,"item_types":[{"kind":"string","length":5}]},"4989950638959520334":{"error_kind":"fmtstring","length":32,"item_types":[{"kind":"string","length":17}]},"5019202896831570965":{"error_kind":"string","string":"attempt to add with overflow"},"5493362915830397726":{"error_kind":"string","string":"Prefix must be 0, 1, 2 or 3"},"5655419122065692946":{"error_kind":"string","string":"Length of length exceeds input length"},"5727012404371710682":{"error_kind":"string","string":"push out of bounds"},"6236500010476601753":{"error_kind":"fmtstring","length":32,"item_types":[{"kind":"string","length":7}]},"6360937559958062612":{"error_kind":"string","string":"Cannot pop from an empty fragment"},"6485997221020871071":{"error_kind":"string","string":"call to assert_max_bit_size"},"6768678589290466106":{"error_kind":"fmtstring","length":30,"item_types":[{"kind":"string","length":9}]},"6797140530996405384":{"error_kind":"fmtstring","length":31,"item_types":[{"kind":"string","length":7}]},"7233212735005103307":{"error_kind":"string","string":"attempt to multiply with overflow"},"7512174461964532630":{"error_kind":"fmtstring","length":30,"item_types":[{"kind":"string","length":10}]},"7673055947793783294":{"error_kind":"string","string":"Element is not a string of length < 56 bytes"},"7701088741439810963":{"error_kind":"string","string":"Expected a hash at the end of the extension node"},"7727927684323588447":{"error_kind":"string","string":"Expected a hash at position given by the key nibble"},"7729612060405699720":{"error_kind":"string","string":"Node RLP length exceeds MAX_LEN"},"7932861116973345373":{"error_kind":"string","string":"Value mismatch"},"7976774808975071288":{"error_kind":"string","string":"Bytes implicit data length must be at least 2 times larger than bytes explicit length"},"8449533356146759774":{"error_kind":"string","string":"Extension key part does not correspond to given key nibbles"},"8647927282746596079":{"error_kind":"fmtstring","length":30,"item_types":[{"kind":"string","length":13}]},"8764575204013396926":{"error_kind":"string","string":"Leaf parity prefix must be 2 or 3"},"8940778978892985534":{"error_kind":"string","string":"Key mismatch in the leaf"},"9003498225274356583":{"error_kind":"fmtstring","length":30,"item_types":[{"kind":"string","length":17}]},"9262262581089067316":{"error_kind":"string","string":"Length of length is zero"},"9610804029702890081":{"error_kind":"string","string":"Inconsistent rlp length"},"9733638806613941694":{"error_kind":"fmtstring","length":77,"item_types":[{"kind":"integer","sign":"unsigned","width":32},{"kind":"integer","sign":"unsigned","width":32}]},"9931858164094679337":{"error_kind":"fmtstring","length":30,"item_types":[{"kind":"string","length":12}]},"10029016582456820804":{"error_kind":"string","string":"Fragment length exceeds data length"},"10459214753737813644":{"error_kind":"string","string":"Total length exceeds input length"},"10736731826012069778":{"error_kind":"fmtstring","length":31,"item_types":[{"kind":"string","length":9}]},"10854030354164654860":{"error_kind":"string","string":"Address mismatch"},"11183658210205501665":{"error_kind":"fmtstring","length":30,"item_types":[{"kind":"string","length":5}]},"11201295997920925782":{"error_kind":"string","string":"Expected a zero after a prefix of even parity"},"13113033765825030666":{"error_kind":"fmtstring","length":32,"item_types":[{"kind":"string","length":10}]},"13169712016435268629":{"error_kind":"string","string":"Decoded length of long list exceeds input length"},"13521589430615575074":{"error_kind":"fmtstring","length":31,"item_types":[{"kind":"string","length":13}]},"13851312983424125104":{"error_kind":"fmtstring","length":32,"item_types":[{"kind":"string","length":5}]},"13857984082167849225":{"error_kind":"string","string":"Invalid node hash"},"14130454602814610950":{"error_kind":"string","string":"Extension parity prefix must be 0 or 1"},"14177523539272545097":{"error_kind":"string","string":"Array index out of bound"},"14225679739041873922":{"error_kind":"string","string":"Index out of bounds"},"14384811266519685328":{"error_kind":"string","string":"Subfragment overflows fragment"},"14420715966409058246":{"error_kind":"string","string":"Length of length exceeds maximum"},"14462956016171063393":{"error_kind":"string","string":"Leaf expected to have 2 fields"},"14651816509643900852":{"error_kind":"string","string":"Decoded length of short string exceeds input length"},"14729908539421612020":{"error_kind":"fmtstring","length":30,"item_types":[{"kind":"string","length":7}]},"14911434386120940114":{"error_kind":"string","string":"Invalid number of fields in account RLP"},"15862946155048515401":{"error_kind":"string","string":"Decoded length of short list exceeds input length"},"15864849592686294349":{"error_kind":"fmtstring","length":32,"item_types":[{"kind":"string","length":9}]},"16538375868159084754":{"error_kind":"string","string":"Block number does not match the argument"},"16761564377371454734":{"error_kind":"string","string":"Array index out of bounds"},"16954218183513903507":{"error_kind":"string","string":"Attempted to read past end of BoundedVec"},"17362798791118512561":{"error_kind":"fmtstring","length":31,"item_types":[{"kind":"string","length":10}]},"17772659172029321311":{"error_kind":"fmtstring","length":32,"item_types":[{"kind":"string","length":13}]},"17843811134343075018":{"error_kind":"string","string":"Stack too deep"}}},"bytecode":"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","debug_symbols":"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ZY1XV7JxPc9DiOn3wyFk/zcbx6f/GmP6/fRfHenX01J4OOtL5awhvz/88J5v7X28tffp1t7nW3svt/Ze7+x9gynMb3pPt/be39r7W9faBtOu3/T+1rU23LrWhlvX2nDrWhtuXWv51rWWb11r+da1lm9daxtMnH/T+1vXWr51reVb11q+da3lW9faeOtaG29da+Ota228da1toPr4pve3rrXx1rU23rrWxlvX2njrWptuXWvTrWttunWt/YM+KunzVz779Nn7at/5D/qotjaigY1kYCMb2BADG9rfxh/0UW1tkIENb2DDIM+zQZ5ngzzPBnmeDfI8G+R5NshzMchzMchzMchzMchzMchzMchzMchzMchzMchzMchzNchzNchzNchzNchzNchzNchzNchzNchzNchzvZ7ntRnh5K7n+fd2zMnRrb33t/Y+3Np7vrX38dbep1t7n2/tvdzae72z93TrWku3rrV061pLt661dOtaS7eutXTrWku3rrV061pLt661/ta11t+61vpb11p/61rrb11r/a1rrb91rfW3rrX+1rXW37rWhlvX2nDrWhtuXWvDrWttuHWtDbeuteHWtTbcutaGW9facOta+wfVtCg9vde//u4n72t95/QHbXNbG97ARjCwwQY2ooGNZGAjG9gQAxva30Y0yPNokOfRIM+jQZ5HgzyPBnkeDfI8GuR5NMjzaJDnySDPk0GeJ4M8TwZ5ngzyPBnkeTLI82SQ58kgz5NBnmeDPM8GeZ4N8jwb5Hk2yPNskOf5ep5XZ4Tz9Tz/4o45y6291zt7L+7W3tOtvfe39j7c2nu+tffx1t6nW3t/61ort661cutaq7eutXrrWqu3rrV661qrt661eutaq7eutXrrWqu3rrV651qb3Z1rbXZ3rrXZ3bnWZnfnWpvdnWttdneutdndudZmd+dam92da212t661dOtaS7eutXTrWku3rrV061pLt661dOtaW1ZNB6Kn98G//Wrz/vErOfUrPfOrsjq3+is69St/6lfh1K/41K/iqV+lU7869W74U++GP/VuhFPvRjj1boRT70Y49W6EU+9GOPVuhFPvRjj1boRT70Y49W7wqXeDT70bfOrd4FPvBp96N/jUu8Gn3g0+9W7wqXeDT70b8dS7EU+9G/HUuxFPvRvx1LsRT70b8dS7EU+9G/HUuxFPvRvp1LuR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","file_map":{"3":{"source":"use crate::cmp::{Eq, Ord};\nuse crate::convert::From;\nuse crate::runtime::is_unconstrained;\n\nmod check_shuffle;\nmod quicksort;\n\nimpl<T, let N: u32> [T; N] {\n    /// Returns the length of this array.\n    ///\n    /// ```noir\n    /// fn len(self) -> Field\n    /// ```\n    ///\n    /// example\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let array = [42, 42];\n    ///     assert(array.len() == 2);\n    /// }\n    /// ```\n    #[builtin(array_len)]\n    pub fn len(self) -> u32 {}\n\n    /// Returns this array as a slice.\n    ///\n    /// ```noir\n    /// let array = [1, 2];\n    /// let slice = array.as_slice();\n    /// assert_eq(slice, &[1, 2]);\n    /// ```\n    #[builtin(as_slice)]\n    pub fn as_slice(self) -> [T] {}\n\n    /// Applies a function to each element of this array, returning a new array containing the mapped elements.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// let a = [1, 2, 3];\n    /// let b = a.map(|a| a * 2);\n    /// assert_eq(b, [2, 4, 6]);\n    /// ```\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> [U; N] {\n        let uninitialized = crate::mem::zeroed();\n        let mut ret = [uninitialized; N];\n\n        for i in 0..self.len() {\n            ret[i] = f(self[i]);\n        }\n\n        ret\n    }\n\n    /// Applies a function to each element of the array, returning the final accumulated value. The first\n    /// parameter is the initial value.\n    ///\n    /// This is a left fold, so the given function will be applied to the accumulator and first element of\n    /// the array, then the second, and so on. For a given call the expected result would be equivalent to:\n    ///\n    /// ```rust\n    /// let a1 = [1];\n    /// let a2 = [1, 2];\n    /// let a3 = [1, 2, 3];\n    ///\n    /// let f = |a, b| a - b;\n    /// a1.fold(10, f); //=> f(10, 1)\n    /// a2.fold(10, f); //=> f(f(10, 1), 2)\n    /// a3.fold(10, f); //=> f(f(f(10, 1), 2), 3)\n    ///\n    /// assert_eq(a3.fold(10, f), 10 - 1 - 2 - 3);\n    /// ```\n    pub fn fold<U, Env>(self, mut accumulator: U, f: fn[Env](U, T) -> U) -> U {\n        for elem in self {\n            accumulator = f(accumulator, elem);\n        }\n        accumulator\n    }\n\n    /// Same as fold, but uses the first element as the starting element.\n    ///\n    /// Requires the input array to be non-empty.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let arr = [1, 2, 3, 4];\n    ///     let reduced = arr.reduce(|a, b| a + b);\n    ///     assert(reduced == 10);\n    /// }\n    /// ```\n    pub fn reduce<Env>(self, f: fn[Env](T, T) -> T) -> T {\n        let mut accumulator = self[0];\n        for i in 1..self.len() {\n            accumulator = f(accumulator, self[i]);\n        }\n        accumulator\n    }\n\n    /// Returns true if all the elements in this array satisfy the given predicate.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let arr = [2, 2, 2, 2, 2];\n    ///     let all = arr.all(|a| a == 2);\n    ///     assert(all);\n    /// }\n    /// ```\n    pub fn all<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = true;\n        for elem in self {\n            ret &= predicate(elem);\n        }\n        ret\n    }\n\n    /// Returns true if any of the elements in this array satisfy the given predicate.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let arr = [2, 2, 2, 2, 5];\n    ///     let any = arr.any(|a| a == 5);\n    ///     assert(any);\n    /// }\n    /// ```\n    pub fn any<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = false;\n        for elem in self {\n            ret |= predicate(elem);\n        }\n        ret\n    }\n}\n\nimpl<T, let N: u32> [T; N]\nwhere\n    T: Ord + Eq,\n{\n    /// Returns a new sorted array. The original array remains untouched. Notice that this function will\n    /// only work for arrays of fields or integers, not for any arbitrary type. This is because the sorting\n    /// logic it uses internally is optimized specifically for these values. If you need a sort function to\n    /// sort any type, you should use the `sort_via` function.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// fn main() {\n    ///     let arr = [42, 32];\n    ///     let sorted = arr.sort();\n    ///     assert(sorted == [32, 42]);\n    /// }\n    /// ```\n    pub fn sort(self) -> Self {\n        self.sort_via(|a, b| a <= b)\n    }\n}\n\nimpl<T, let N: u32> [T; N]\nwhere\n    T: Eq,\n{\n    /// Returns a new sorted array by sorting it with a custom comparison function.\n    /// The original array remains untouched.\n    /// The ordering function must return true if the first argument should be sorted to be before the second argument or is equal to the second argument.\n    ///\n    /// Using this method with an operator like `<` that does not return `true` for equal values will result in an assertion failure for arrays with equal elements.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// fn main() {\n    ///     let arr = [42, 32]\n    ///     let sorted_ascending = arr.sort_via(|a, b| a <= b);\n    ///     assert(sorted_ascending == [32, 42]); // verifies\n    ///\n    ///     let sorted_descending = arr.sort_via(|a, b| a >= b);\n    ///     assert(sorted_descending == [32, 42]); // does not verify\n    /// }\n    /// ```\n    pub fn sort_via<Env>(self, ordering: fn[Env](T, T) -> bool) -> Self {\n        // Safety: `sorted` array is checked to be:\n        // a. a permutation of `input`'s elements\n        // b. satisfying the predicate `ordering`\n        unsafe {\n            let sorted = quicksort::quicksort(self, ordering);\n\n            if !is_unconstrained() {\n                for i in 0..N - 1 {\n                    assert(\n                        ordering(sorted[i], sorted[i + 1]),\n                        \"Array has not been sorted correctly according to `ordering`.\",\n                    );\n                }\n                check_shuffle::check_shuffle(self, sorted);\n            }\n            sorted\n        }\n    }\n}\n\nimpl<let N: u32> [u8; N] {\n    /// Converts a byte array of type `[u8; N]` to a string. Note that this performs no UTF-8 validation -\n    /// the given array is interpreted as-is as a string.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// fn main() {\n    ///     let hi = [104, 105].as_str_unchecked();\n    ///     assert_eq(hi, \"hi\");\n    /// }\n    /// ```\n    #[builtin(array_as_str_unchecked)]\n    pub fn as_str_unchecked(self) -> str<N> {}\n}\n\nimpl<let N: u32> From<str<N>> for [u8; N] {\n    /// Returns an array of the string bytes.\n    fn from(s: str<N>) -> Self {\n        s.as_bytes()\n    }\n}\n\nmod test {\n    #[test]\n    fn map_empty() {\n        assert_eq([].map(|x| x + 1), []);\n    }\n}\n","path":"std/array/mod.nr"},"5":{"source":"use crate::meta::derive_via;\n\n#[derive_via(derive_eq)]\n// docs:start:eq-trait\npub trait Eq {\n    fn eq(self, other: Self) -> bool;\n}\n// docs:end:eq-trait\n\n// docs:start:derive_eq\ncomptime fn derive_eq(s: StructDefinition) -> Quoted {\n    let signature = quote { fn eq(_self: Self, _other: Self) -> bool };\n    let for_each_field = |name| quote { (_self.$name == _other.$name) };\n    let body = |fields| {\n        if s.fields_as_written().len() == 0 {\n            quote { true }\n        } else {\n            fields\n        }\n    };\n    crate::meta::make_trait_impl(\n        s,\n        quote { Eq },\n        signature,\n        for_each_field,\n        quote { & },\n        body,\n    )\n}\n// docs:end:derive_eq\n\nimpl Eq for Field {\n    fn eq(self, other: Field) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for u128 {\n    fn eq(self, other: u128) -> bool {\n        self == other\n    }\n}\nimpl Eq for u64 {\n    fn eq(self, other: u64) -> bool {\n        self == other\n    }\n}\nimpl Eq for u32 {\n    fn eq(self, other: u32) -> bool {\n        self == other\n    }\n}\nimpl Eq for u16 {\n    fn eq(self, other: u16) -> bool {\n        self == other\n    }\n}\nimpl Eq for u8 {\n    fn eq(self, other: u8) -> bool {\n        self == other\n    }\n}\nimpl Eq for u1 {\n    fn eq(self, other: u1) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for i8 {\n    fn eq(self, other: i8) -> bool {\n        self == other\n    }\n}\nimpl Eq for i16 {\n    fn eq(self, other: i16) -> bool {\n        self == other\n    }\n}\nimpl Eq for i32 {\n    fn eq(self, other: i32) -> bool {\n        self == other\n    }\n}\nimpl Eq for i64 {\n    fn eq(self, other: i64) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for () {\n    fn eq(_self: Self, _other: ()) -> bool {\n        true\n    }\n}\nimpl Eq for bool {\n    fn eq(self, other: bool) -> bool {\n        self == other\n    }\n}\n\nimpl<T, let N: u32> Eq for [T; N]\nwhere\n    T: Eq,\n{\n    fn eq(self, other: [T; N]) -> bool {\n        let mut result = true;\n        for i in 0..self.len() {\n            result &= self[i].eq(other[i]);\n        }\n        result\n    }\n}\n\nimpl<T> Eq for [T]\nwhere\n    T: Eq,\n{\n    fn eq(self, other: [T]) -> bool {\n        let mut result = self.len() == other.len();\n        for i in 0..self.len() {\n            result &= self[i].eq(other[i]);\n        }\n        result\n    }\n}\n\nimpl<let N: u32> Eq for str<N> {\n    fn eq(self, other: str<N>) -> bool {\n        let self_bytes = self.as_bytes();\n        let other_bytes = other.as_bytes();\n        self_bytes == other_bytes\n    }\n}\n\nimpl<A, B> Eq for (A, B)\nwhere\n    A: Eq,\n    B: Eq,\n{\n    fn eq(self, other: (A, B)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1)\n    }\n}\n\nimpl<A, B, C> Eq for (A, B, C)\nwhere\n    A: Eq,\n    B: Eq,\n    C: Eq,\n{\n    fn eq(self, other: (A, B, C)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1) & self.2.eq(other.2)\n    }\n}\n\nimpl<A, B, C, D> Eq for (A, B, C, D)\nwhere\n    A: Eq,\n    B: Eq,\n    C: Eq,\n    D: Eq,\n{\n    fn eq(self, other: (A, B, C, D)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1) & self.2.eq(other.2) & self.3.eq(other.3)\n    }\n}\n\nimpl<A, B, C, D, E> Eq for (A, B, C, D, E)\nwhere\n    A: Eq,\n    B: Eq,\n    C: Eq,\n    D: Eq,\n    E: Eq,\n{\n    fn eq(self, other: (A, B, C, D, E)) -> bool {\n        self.0.eq(other.0)\n            & self.1.eq(other.1)\n            & self.2.eq(other.2)\n            & self.3.eq(other.3)\n            & self.4.eq(other.4)\n    }\n}\n\nimpl Eq for Ordering {\n    fn eq(self, other: Ordering) -> bool {\n        self.result == other.result\n    }\n}\n\n// Noir doesn't have enums yet so we emulate (Lt | Eq | Gt) with a struct\n// that has 3 public functions for constructing the struct.\npub struct Ordering {\n    result: Field,\n}\n\nimpl Ordering {\n    // Implementation note: 0, 1, and 2 for Lt, Eq, and Gt are built\n    // into the compiler, do not change these without also updating\n    // the compiler itself!\n    pub fn less() -> Ordering {\n        Ordering { result: 0 }\n    }\n\n    pub fn equal() -> Ordering {\n        Ordering { result: 1 }\n    }\n\n    pub fn greater() -> Ordering {\n        Ordering { result: 2 }\n    }\n}\n\n#[derive_via(derive_ord)]\n// docs:start:ord-trait\npub trait Ord {\n    fn cmp(self, other: Self) -> Ordering;\n}\n// docs:end:ord-trait\n\n// docs:start:derive_ord\ncomptime fn derive_ord(s: StructDefinition) -> Quoted {\n    let signature = quote { fn cmp(_self: Self, _other: Self) -> std::cmp::Ordering };\n    let for_each_field = |name| quote {\n        if result == std::cmp::Ordering::equal() {\n            result = _self.$name.cmp(_other.$name);\n        }\n    };\n    let body = |fields| quote {\n        let mut result = std::cmp::Ordering::equal();\n        $fields\n        result\n    };\n    crate::meta::make_trait_impl(s, quote { Ord }, signature, for_each_field, quote {}, body)\n}\n// docs:end:derive_ord\n\n// Note: Field deliberately does not implement Ord\n\nimpl Ord for u128 {\n    fn cmp(self, other: u128) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\nimpl Ord for u64 {\n    fn cmp(self, other: u64) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u32 {\n    fn cmp(self, other: u32) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u16 {\n    fn cmp(self, other: u16) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u8 {\n    fn cmp(self, other: u8) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i8 {\n    fn cmp(self, other: i8) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i16 {\n    fn cmp(self, other: i16) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i32 {\n    fn cmp(self, other: i32) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i64 {\n    fn cmp(self, other: i64) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for () {\n    fn cmp(_self: Self, _other: ()) -> Ordering {\n        Ordering::equal()\n    }\n}\n\nimpl Ord for bool {\n    fn cmp(self, other: bool) -> Ordering {\n        if self {\n            if other {\n                Ordering::equal()\n            } else {\n                Ordering::greater()\n            }\n        } else if other {\n            Ordering::less()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl<T, let N: u32> Ord for [T; N]\nwhere\n    T: Ord,\n{\n    // The first non-equal element of both arrays determines\n    // the ordering for the whole array.\n    fn cmp(self, other: [T; N]) -> Ordering {\n        let mut result = Ordering::equal();\n        for i in 0..self.len() {\n            if result == Ordering::equal() {\n                result = self[i].cmp(other[i]);\n            }\n        }\n        result\n    }\n}\n\nimpl<T> Ord for [T]\nwhere\n    T: Ord,\n{\n    // The first non-equal element of both arrays determines\n    // the ordering for the whole array.\n    fn cmp(self, other: [T]) -> Ordering {\n        let mut result = self.len().cmp(other.len());\n        for i in 0..self.len() {\n            if result == Ordering::equal() {\n                result = self[i].cmp(other[i]);\n            }\n        }\n        result\n    }\n}\n\nimpl<A, B> Ord for (A, B)\nwhere\n    A: Ord,\n    B: Ord,\n{\n    fn cmp(self, other: (A, B)) -> Ordering {\n        let result = self.0.cmp(other.0);\n\n        if result != Ordering::equal() {\n            result\n        } else {\n            self.1.cmp(other.1)\n        }\n    }\n}\n\nimpl<A, B, C> Ord for (A, B, C)\nwhere\n    A: Ord,\n    B: Ord,\n    C: Ord,\n{\n    fn cmp(self, other: (A, B, C)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        result\n    }\n}\n\nimpl<A, B, C, D> Ord for (A, B, C, D)\nwhere\n    A: Ord,\n    B: Ord,\n    C: Ord,\n    D: Ord,\n{\n    fn cmp(self, other: (A, B, C, D)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        if result == Ordering::equal() {\n            result = self.3.cmp(other.3);\n        }\n\n        result\n    }\n}\n\nimpl<A, B, C, D, E> Ord for (A, B, C, D, E)\nwhere\n    A: Ord,\n    B: Ord,\n    C: Ord,\n    D: Ord,\n    E: Ord,\n{\n    fn cmp(self, other: (A, B, C, D, E)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        if result == Ordering::equal() {\n            result = self.3.cmp(other.3);\n        }\n\n        if result == Ordering::equal() {\n            result = self.4.cmp(other.4);\n        }\n\n        result\n    }\n}\n\n// Compares and returns the maximum of two values.\n//\n// Returns the second argument if the comparison determines them to be equal.\n//\n// # Examples\n//\n// ```\n// use std::cmp;\n//\n// assert_eq(cmp::max(1, 2), 2);\n// assert_eq(cmp::max(2, 2), 2);\n// ```\npub fn max<T>(v1: T, v2: T) -> T\nwhere\n    T: Ord,\n{\n    if v1 > v2 {\n        v1\n    } else {\n        v2\n    }\n}\n\n// Compares and returns the minimum of two values.\n//\n// Returns the first argument if the comparison determines them to be equal.\n//\n// # Examples\n//\n// ```\n// use std::cmp;\n//\n// assert_eq(cmp::min(1, 2), 1);\n// assert_eq(cmp::min(2, 2), 2);\n// ```\npub fn min<T>(v1: T, v2: T) -> T\nwhere\n    T: Ord,\n{\n    if v1 > v2 {\n        v2\n    } else {\n        v1\n    }\n}\n\nmod cmp_tests {\n    use crate::cmp::{max, min};\n\n    #[test]\n    fn sanity_check_min() {\n        assert_eq(min(0 as u64, 1 as u64), 0);\n        assert_eq(min(0 as u64, 0 as u64), 0);\n        assert_eq(min(1 as u64, 1 as u64), 1);\n        assert_eq(min(255 as u8, 0 as u8), 0);\n    }\n\n    #[test]\n    fn sanity_check_max() {\n        assert_eq(max(0 as u64, 1 as u64), 1);\n        assert_eq(max(0 as u64, 0 as u64), 0);\n        assert_eq(max(1 as u64, 1 as u64), 1);\n        assert_eq(max(255 as u8, 0 as u8), 255);\n    }\n}\n","path":"std/cmp.nr"},"6":{"source":"use crate::{cmp::Eq, convert::From, runtime::is_unconstrained, static_assert};\n\n/// A `BoundedVec<T, MaxLen>` is a growable storage similar to a `Vec<T>` except that it\n/// is bounded with a maximum possible length. Unlike `Vec`, `BoundedVec` is not implemented\n/// via slices and thus is not subject to the same restrictions slices are (notably, nested\n/// slices - and thus nested vectors as well - are disallowed).\n///\n/// Since a BoundedVec is backed by a normal array under the hood, growing the BoundedVec by\n/// pushing an additional element is also more efficient - the length only needs to be increased\n/// by one.\n///\n/// For these reasons `BoundedVec<T, N>` should generally be preferred over `Vec<T>` when there\n/// is a reasonable maximum bound that can be placed on the vector.\n///\n/// Example:\n///\n/// ```noir\n/// let mut vector: BoundedVec<Field, 10> = BoundedVec::new();\n/// for i in 0..5 {\n///     vector.push(i);\n/// }\n/// assert(vector.len() == 5);\n/// assert(vector.max_len() == 10);\n/// ```\npub struct BoundedVec<T, let MaxLen: u32> {\n    storage: [T; MaxLen],\n    len: u32,\n}\n\nimpl<T, let MaxLen: u32> BoundedVec<T, MaxLen> {\n    /// Creates a new, empty vector of length zero.\n    ///\n    /// Since this container is backed by an array internally, it still needs an initial value\n    /// to give each element. To resolve this, each element is zeroed internally. This value\n    /// is guaranteed to be inaccessible unless `get_unchecked` is used.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let empty_vector: BoundedVec<Field, 10> = BoundedVec::new();\n    /// assert(empty_vector.len() == 0);\n    /// ```\n    ///\n    /// Note that whenever calling `new` the maximum length of the vector should always be specified\n    /// via a type signature:\n    ///\n    /// ```noir\n    /// fn good() -> BoundedVec<Field, 10> {\n    ///     // Ok! MaxLen is specified with a type annotation\n    ///     let v1: BoundedVec<Field, 3> = BoundedVec::new();\n    ///     let v2 = BoundedVec::new();\n    ///\n    ///     // Ok! MaxLen is known from the type of `good`'s return value\n    ///     v2\n    /// }\n    ///\n    /// fn bad() {\n    ///     // Error: Type annotation needed\n    ///     // The compiler can't infer `MaxLen` from the following code:\n    ///     let mut v3 = BoundedVec::new();\n    ///     v3.push(5);\n    /// }\n    /// ```\n    ///\n    /// This defaulting of `MaxLen` (and numeric generics in general) to zero may change in future noir versions\n    /// but for now make sure to use type annotations when using bounded vectors. Otherwise, you will receive a\n    /// constraint failure at runtime when the vec is pushed to.\n    pub fn new() -> Self {\n        let zeroed = crate::mem::zeroed();\n        BoundedVec { storage: [zeroed; MaxLen], len: 0 }\n    }\n\n    /// Retrieves an element from the vector at the given index, starting from zero.\n    ///\n    /// If the given index is equal to or greater than the length of the vector, this\n    /// will issue a constraint failure.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn foo<let N: u32>(v: BoundedVec<u32, N>) {\n    ///     let first = v.get(0);\n    ///     let last = v.get(v.len() - 1);\n    ///     assert(first != last);\n    /// }\n    /// ```\n    pub fn get(self, index: u32) -> T {\n        assert(index < self.len, \"Attempted to read past end of BoundedVec\");\n        self.get_unchecked(index)\n    }\n\n    /// Retrieves an element from the vector at the given index, starting from zero, without\n    /// performing a bounds check.\n    ///\n    /// Since this function does not perform a bounds check on length before accessing the element,\n    /// it is unsafe! Use at your own risk!\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn sum_of_first_three<let N: u32>(v: BoundedVec<u32, N>) -> u32 {\n    ///     // Always ensure the length is larger than the largest\n    ///     // index passed to get_unchecked\n    ///     assert(v.len() > 2);\n    ///     let first = v.get_unchecked(0);\n    ///     let second = v.get_unchecked(1);\n    ///     let third = v.get_unchecked(2);\n    ///     first + second + third\n    /// }\n    /// ```\n    pub fn get_unchecked(self, index: u32) -> T {\n        self.storage[index]\n    }\n\n    /// Writes an element to the vector at the given index, starting from zero.\n    ///\n    /// If the given index is equal to or greater than the length of the vector, this will issue a constraint failure.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn foo<let N: u32>(v: BoundedVec<u32, N>) {\n    ///     let first = v.get(0);\n    ///     assert(first != 42);\n    ///     v.set(0, 42);\n    ///     let new_first = v.get(0);\n    ///     assert(new_first == 42);\n    /// }\n    /// ```\n    pub fn set(&mut self, index: u32, value: T) {\n        assert(index < self.len, \"Attempted to write past end of BoundedVec\");\n        self.set_unchecked(index, value)\n    }\n\n    /// Writes an element to the vector at the given index, starting from zero, without performing a bounds check.\n    ///\n    /// Since this function does not perform a bounds check on length before accessing the element, it is unsafe! Use at your own risk!\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn set_unchecked_example() {\n    ///     let mut vec: BoundedVec<u32, 5> = BoundedVec::new();\n    ///     vec.extend_from_array([1, 2]);\n    ///\n    ///     // Here we're safely writing within the valid range of `vec`\n    ///     // `vec` now has the value [42, 2]\n    ///     vec.set_unchecked(0, 42);\n    ///\n    ///     // We can then safely read this value back out of `vec`.\n    ///     // Notice that we use the checked version of `get` which would prevent reading unsafe values.\n    ///     assert_eq(vec.get(0), 42);\n    ///\n    ///     // We've now written past the end of `vec`.\n    ///     // As this index is still within the maximum potential length of `v`,\n    ///     // it won't cause a constraint failure.\n    ///     vec.set_unchecked(2, 42);\n    ///     println(vec);\n    ///\n    ///     // This will write past the end of the maximum potential length of `vec`,\n    ///     // it will then trigger a constraint failure.\n    ///     vec.set_unchecked(5, 42);\n    ///     println(vec);\n    /// }\n    /// ```\n    pub fn set_unchecked(&mut self, index: u32, value: T) {\n        self.storage[index] = value;\n    }\n\n    /// Pushes an element to the end of the vector. This increases the length\n    /// of the vector by one.\n    ///\n    /// Panics if the new length of the vector will be greater than the max length.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 2> = BoundedVec::new();\n    ///\n    /// v.push(1);\n    /// v.push(2);\n    ///\n    /// // Panics with failed assertion \"push out of bounds\"\n    /// v.push(3);\n    /// ```\n    pub fn push(&mut self, elem: T) {\n        assert(self.len < MaxLen, \"push out of bounds\");\n\n        self.storage[self.len] = elem;\n        self.len += 1;\n    }\n\n    /// Returns the current length of this vector\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 4> = BoundedVec::new();\n    /// assert(v.len() == 0);\n    ///\n    /// v.push(100);\n    /// assert(v.len() == 1);\n    ///\n    /// v.push(200);\n    /// v.push(300);\n    /// v.push(400);\n    /// assert(v.len() == 4);\n    ///\n    /// let _ = v.pop();\n    /// let _ = v.pop();\n    /// assert(v.len() == 2);\n    /// ```\n    pub fn len(self) -> u32 {\n        self.len\n    }\n\n    /// Returns the maximum length of this vector. This is always\n    /// equal to the `MaxLen` parameter this vector was initialized with.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 5> = BoundedVec::new();\n    ///\n    /// assert(v.max_len() == 5);\n    /// v.push(10);\n    /// assert(v.max_len() == 5);\n    /// ```\n    pub fn max_len(_self: BoundedVec<T, MaxLen>) -> u32 {\n        MaxLen\n    }\n\n    /// Returns the internal array within this vector.\n    ///\n    /// Since arrays in Noir are immutable, mutating the returned storage array will not mutate\n    /// the storage held internally by this vector.\n    ///\n    /// Note that uninitialized elements may be zeroed out!\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 5> = BoundedVec::new();\n    ///\n    /// assert(v.storage() == [0, 0, 0, 0, 0]);\n    ///\n    /// v.push(57);\n    /// assert(v.storage() == [57, 0, 0, 0, 0]);\n    /// ```\n    pub fn storage(self) -> [T; MaxLen] {\n        self.storage\n    }\n\n    /// Pushes each element from the given array to this vector.\n    ///\n    /// Panics if pushing each element would cause the length of this vector\n    /// to exceed the maximum length.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut vec: BoundedVec<Field, 3> = BoundedVec::new();\n    /// vec.extend_from_array([2, 4]);\n    ///\n    /// assert(vec.len == 2);\n    /// assert(vec.get(0) == 2);\n    /// assert(vec.get(1) == 4);\n    /// ```\n    pub fn extend_from_array<let Len: u32>(&mut self, array: [T; Len]) {\n        let new_len = self.len + array.len();\n        assert(new_len <= MaxLen, \"extend_from_array out of bounds\");\n        for i in 0..array.len() {\n            self.storage[self.len + i] = array[i];\n        }\n        self.len = new_len;\n    }\n\n    /// Pushes each element from the given slice to this vector.\n    ///\n    /// Panics if pushing each element would cause the length of this vector\n    /// to exceed the maximum length.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut vec: BoundedVec<Field, 3> = BoundedVec::new();\n    /// vec.extend_from_slice(&[2, 4]);\n    ///\n    /// assert(vec.len == 2);\n    /// assert(vec.get(0) == 2);\n    /// assert(vec.get(1) == 4);\n    /// ```\n    pub fn extend_from_slice(&mut self, slice: [T]) {\n        let new_len = self.len + slice.len();\n        assert(new_len <= MaxLen, \"extend_from_slice out of bounds\");\n        for i in 0..slice.len() {\n            self.storage[self.len + i] = slice[i];\n        }\n        self.len = new_len;\n    }\n\n    /// Pushes each element from the other vector to this vector. The length of\n    /// the other vector is left unchanged.\n    ///\n    /// Panics if pushing each element would cause the length of this vector\n    /// to exceed the maximum length.\n    ///\n    /// ```noir\n    /// let mut v1: BoundedVec<Field, 5> = BoundedVec::new();\n    /// let mut v2: BoundedVec<Field, 7> = BoundedVec::new();\n    ///\n    /// v2.extend_from_array([1, 2, 3]);\n    /// v1.extend_from_bounded_vec(v2);\n    ///\n    /// assert(v1.storage() == [1, 2, 3, 0, 0]);\n    /// assert(v2.storage() == [1, 2, 3, 0, 0, 0, 0]);\n    /// ```\n    pub fn extend_from_bounded_vec<let Len: u32>(&mut self, vec: BoundedVec<T, Len>) {\n        let append_len = vec.len();\n        let new_len = self.len + append_len;\n        assert(new_len <= MaxLen, \"extend_from_bounded_vec out of bounds\");\n\n        if is_unconstrained() {\n            for i in 0..append_len {\n                self.storage[self.len + i] = vec.get_unchecked(i);\n            }\n        } else {\n            let mut exceeded_len = false;\n            for i in 0..Len {\n                exceeded_len |= i == append_len;\n                if !exceeded_len {\n                    self.storage[self.len + i] = vec.get_unchecked(i);\n                }\n            }\n        }\n        self.len = new_len;\n    }\n\n    /// Creates a new vector, populating it with values derived from an array input.\n    /// The maximum length of the vector is determined based on the type signature.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let bounded_vec: BoundedVec<Field, 10> = BoundedVec::from_array([1, 2, 3])\n    /// ```\n    pub fn from_array<let Len: u32>(array: [T; Len]) -> Self {\n        static_assert(Len <= MaxLen, \"from array out of bounds\");\n        let mut vec: BoundedVec<T, MaxLen> = BoundedVec::new();\n        vec.extend_from_array(array);\n        vec\n    }\n\n    /// Pops the element at the end of the vector. This will decrease the length\n    /// of the vector by one.\n    ///\n    /// Panics if the vector is empty.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 2> = BoundedVec::new();\n    /// v.push(1);\n    /// v.push(2);\n    ///\n    /// let two = v.pop();\n    /// let one = v.pop();\n    ///\n    /// assert(two == 2);\n    /// assert(one == 1);\n    ///\n    /// // error: cannot pop from an empty vector\n    /// let _ = v.pop();\n    /// ```\n    pub fn pop(&mut self) -> T {\n        assert(self.len > 0);\n        self.len -= 1;\n\n        let elem = self.storage[self.len];\n        self.storage[self.len] = crate::mem::zeroed();\n        elem\n    }\n\n    /// Returns true if the given predicate returns true for any element\n    /// in this vector.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<u32, 3> = BoundedVec::new();\n    /// v.extend_from_array([2, 4, 6]);\n    ///\n    /// let all_even = !v.any(|elem: u32| elem % 2 != 0);\n    /// assert(all_even);\n    /// ```\n    pub fn any<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = false;\n        if is_unconstrained() {\n            for i in 0..self.len {\n                ret |= predicate(self.storage[i]);\n            }\n        } else {\n            let mut ret = false;\n            let mut exceeded_len = false;\n            for i in 0..MaxLen {\n                exceeded_len |= i == self.len;\n                if !exceeded_len {\n                    ret |= predicate(self.storage[i]);\n                }\n            }\n        }\n        ret\n    }\n\n    /// Creates a new vector of equal size by calling a closure on each element in this vector.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n    /// let result = vec.map(|value| value * 2);\n    ///\n    /// let expected = BoundedVec::from_array([2, 4, 6, 8]);\n    /// assert_eq(result, expected);\n    /// ```\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> BoundedVec<U, MaxLen> {\n        let mut ret = BoundedVec::new();\n        ret.len = self.len();\n\n        if is_unconstrained() {\n            for i in 0..self.len() {\n                ret.storage[i] = f(self.get_unchecked(i));\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i < self.len() {\n                    ret.storage[i] = f(self.get_unchecked(i));\n                }\n            }\n        }\n\n        ret\n    }\n\n    /// Creates a new BoundedVec from the given array and length.\n    /// The given length must be less than or equal to the length of the array.\n    ///\n    /// This function will zero out any elements at or past index `len` of `array`.\n    /// This incurs an extra runtime cost of O(MaxLen). If you are sure your array is\n    /// zeroed after that index, you can use `from_parts_unchecked` to remove the extra loop.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 0], 3);\n    /// assert_eq(vec.len(), 3);\n    /// ```\n    pub fn from_parts(mut array: [T; MaxLen], len: u32) -> Self {\n        assert(len <= MaxLen);\n        let zeroed = crate::mem::zeroed();\n\n        if is_unconstrained() {\n            for i in len..MaxLen {\n                array[i] = zeroed;\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i >= len {\n                    array[i] = zeroed;\n                }\n            }\n        }\n\n        BoundedVec { storage: array, len }\n    }\n\n    /// Creates a new BoundedVec from the given array and length.\n    /// The given length must be less than or equal to the length of the array.\n    ///\n    /// This function is unsafe because it expects all elements past the `len` index\n    /// of `array` to be zeroed, but does not check for this internally. Use `from_parts`\n    /// for a safe version of this function which does zero out any indices past the\n    /// given length. Invalidating this assumption can notably cause `BoundedVec::eq`\n    /// to give incorrect results since it will check even elements past `len`.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 0], 3);\n    /// assert_eq(vec.len(), 3);\n    ///\n    /// // invalid use!\n    /// let vec1: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 1], 3);\n    /// let vec2: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 2], 3);\n    ///\n    /// // both vecs have length 3 so we'd expect them to be equal, but this\n    /// // fails because elements past the length are still checked in eq\n    /// assert_eq(vec1, vec2); // fails\n    /// ```\n    pub fn from_parts_unchecked(array: [T; MaxLen], len: u32) -> Self {\n        assert(len <= MaxLen);\n        BoundedVec { storage: array, len }\n    }\n}\n\nimpl<T, let MaxLen: u32> Eq for BoundedVec<T, MaxLen>\nwhere\n    T: Eq,\n{\n    fn eq(self, other: BoundedVec<T, MaxLen>) -> bool {\n        // TODO: https://github.com/noir-lang/noir/issues/4837\n        //\n        // We make the assumption that the user has used the proper interface for working with `BoundedVec`s\n        // rather than directly manipulating the internal fields as this can result in an inconsistent internal state.\n        if self.len == other.len {\n            self.storage == other.storage\n        } else {\n            false\n        }\n    }\n}\n\nimpl<T, let MaxLen: u32, let Len: u32> From<[T; Len]> for BoundedVec<T, MaxLen> {\n    fn from(array: [T; Len]) -> BoundedVec<T, MaxLen> {\n        BoundedVec::from_array(array)\n    }\n}\n\nmod bounded_vec_tests {\n\n    mod get {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test(should_fail_with = \"Attempted to read past end of BoundedVec\")]\n        fn panics_when_reading_elements_past_end_of_vec() {\n            let vec: BoundedVec<Field, 5> = BoundedVec::new();\n\n            crate::println(vec.get(0));\n        }\n    }\n\n    mod set {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn set_updates_values_properly() {\n            let mut vec = BoundedVec::from_array([0, 0, 0, 0, 0]);\n\n            vec.set(0, 42);\n            assert_eq(vec.storage, [42, 0, 0, 0, 0]);\n\n            vec.set(1, 43);\n            assert_eq(vec.storage, [42, 43, 0, 0, 0]);\n\n            vec.set(2, 44);\n            assert_eq(vec.storage, [42, 43, 44, 0, 0]);\n\n            vec.set(1, 10);\n            assert_eq(vec.storage, [42, 10, 44, 0, 0]);\n\n            vec.set(0, 0);\n            assert_eq(vec.storage, [0, 10, 44, 0, 0]);\n        }\n\n        #[test(should_fail_with = \"Attempted to write past end of BoundedVec\")]\n        fn panics_when_writing_elements_past_end_of_vec() {\n            let mut vec: BoundedVec<Field, 5> = BoundedVec::new();\n            vec.set(0, 42);\n\n            // Need to use println to avoid DIE removing the write operation.\n            crate::println(vec.get(0));\n        }\n    }\n\n    mod map {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn applies_function_correctly() {\n            // docs:start:bounded-vec-map-example\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.map(|value| value * 2);\n            // docs:end:bounded-vec-map-example\n            let expected = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn applies_function_that_changes_return_type() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.map(|value| (value * 2) as Field);\n            let expected: BoundedVec<Field, 4> = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn does_not_apply_function_past_len() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([0, 1]);\n            let result = vec.map(|value| if value == 0 { 5 } else { value });\n            let expected = BoundedVec::from_array([5, 1]);\n\n            assert_eq(result, expected);\n            assert_eq(result.get_unchecked(2), 0);\n        }\n    }\n\n    mod from_array {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn empty() {\n            let empty_array: [Field; 0] = [];\n            let bounded_vec = BoundedVec::from_array([]);\n\n            assert_eq(bounded_vec.max_len(), 0);\n            assert_eq(bounded_vec.len(), 0);\n            assert_eq(bounded_vec.storage(), empty_array);\n        }\n\n        #[test]\n        fn equal_len() {\n            let array = [1, 2, 3];\n            let bounded_vec = BoundedVec::from_array(array);\n\n            assert_eq(bounded_vec.max_len(), 3);\n            assert_eq(bounded_vec.len(), 3);\n            assert_eq(bounded_vec.storage(), array);\n        }\n\n        #[test]\n        fn max_len_greater_then_array_len() {\n            let array = [1, 2, 3];\n            let bounded_vec: BoundedVec<Field, 10> = BoundedVec::from_array(array);\n\n            assert_eq(bounded_vec.max_len(), 10);\n            assert_eq(bounded_vec.len(), 3);\n            assert_eq(bounded_vec.get(0), 1);\n            assert_eq(bounded_vec.get(1), 2);\n            assert_eq(bounded_vec.get(2), 3);\n        }\n\n        #[test(should_fail_with = \"from array out of bounds\")]\n        fn max_len_lower_then_array_len() {\n            let _: BoundedVec<Field, 2> = BoundedVec::from_array([0; 3]);\n        }\n    }\n\n    mod trait_from {\n        use crate::collections::bounded_vec::BoundedVec;\n        use crate::convert::From;\n\n        #[test]\n        fn simple() {\n            let array = [1, 2];\n            let bounded_vec: BoundedVec<Field, 10> = BoundedVec::from(array);\n\n            assert_eq(bounded_vec.max_len(), 10);\n            assert_eq(bounded_vec.len(), 2);\n            assert_eq(bounded_vec.get(0), 1);\n            assert_eq(bounded_vec.get(1), 2);\n        }\n    }\n\n    mod trait_eq {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn empty_equality() {\n            let mut bounded_vec1: BoundedVec<Field, 3> = BoundedVec::new();\n            let mut bounded_vec2: BoundedVec<Field, 3> = BoundedVec::new();\n\n            assert_eq(bounded_vec1, bounded_vec2);\n        }\n\n        #[test]\n        fn inequality() {\n            let mut bounded_vec1: BoundedVec<Field, 3> = BoundedVec::new();\n            let mut bounded_vec2: BoundedVec<Field, 3> = BoundedVec::new();\n            bounded_vec1.push(1);\n            bounded_vec2.push(2);\n\n            assert(bounded_vec1 != bounded_vec2);\n        }\n    }\n\n    mod from_parts {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn from_parts() {\n            // docs:start:from-parts\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 0], 3);\n            assert_eq(vec.len(), 3);\n\n            // Any elements past the given length are zeroed out, so these\n            // two BoundedVecs will be completely equal\n            let vec1: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 1], 3);\n            let vec2: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 2], 3);\n            assert_eq(vec1, vec2);\n            // docs:end:from-parts\n        }\n\n        #[test]\n        fn from_parts_unchecked() {\n            // docs:start:from-parts-unchecked\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 0], 3);\n            assert_eq(vec.len(), 3);\n\n            // invalid use!\n            let vec1: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 1], 3);\n            let vec2: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 2], 3);\n\n            // both vecs have length 3 so we'd expect them to be equal, but this\n            // fails because elements past the length are still checked in eq\n            assert(vec1 != vec2);\n            // docs:end:from-parts-unchecked\n        }\n    }\n}\n","path":"std/collections/bounded_vec.nr"},"12":{"source":"// docs:start:from-trait\npub trait From<T> {\n    fn from(input: T) -> Self;\n}\n// docs:end:from-trait\n\nimpl<T> From<T> for T {\n    fn from(input: T) -> T {\n        input\n    }\n}\n\n// docs:start:into-trait\npub trait Into<T> {\n    fn into(self) -> T;\n}\n\nimpl<T, U> Into<T> for U\nwhere\n    T: From<U>,\n{\n    fn into(self) -> T {\n        T::from(self)\n    }\n}\n// docs:end:into-trait\n\n// docs:start:from-impls\n// Unsigned integers\n\nimpl From<u8> for u32 {\n    fn from(value: u8) -> u32 {\n        value as u32\n    }\n}\n\nimpl From<u8> for u64 {\n    fn from(value: u8) -> u64 {\n        value as u64\n    }\n}\nimpl From<u32> for u64 {\n    fn from(value: u32) -> u64 {\n        value as u64\n    }\n}\n\nimpl From<u8> for u128 {\n    fn from(value: u8) -> u128 {\n        value as u128\n    }\n}\nimpl From<u32> for u128 {\n    fn from(value: u32) -> u128 {\n        value as u128\n    }\n}\nimpl From<u64> for u128 {\n    fn from(value: u64) -> u128 {\n        value as u128\n    }\n}\n\nimpl From<u8> for Field {\n    fn from(value: u8) -> Field {\n        value as Field\n    }\n}\nimpl From<u32> for Field {\n    fn from(value: u32) -> Field {\n        value as Field\n    }\n}\nimpl From<u64> for Field {\n    fn from(value: u64) -> Field {\n        value as Field\n    }\n}\n\nimpl From<u128> for Field {\n    fn from(value: u128) -> Field {\n        value as Field\n    }\n}\n\n// Signed integers\n\nimpl From<i8> for i32 {\n    fn from(value: i8) -> i32 {\n        value as i32\n    }\n}\n\nimpl From<i8> for i64 {\n    fn from(value: i8) -> i64 {\n        value as i64\n    }\n}\nimpl From<i32> for i64 {\n    fn from(value: i32) -> i64 {\n        value as i64\n    }\n}\n\n// Booleans\nimpl From<bool> for u8 {\n    fn from(value: bool) -> u8 {\n        value as u8\n    }\n}\nimpl From<bool> for u32 {\n    fn from(value: bool) -> u32 {\n        value as u32\n    }\n}\nimpl From<bool> for u64 {\n    fn from(value: bool) -> u64 {\n        value as u64\n    }\n}\nimpl From<bool> for i8 {\n    fn from(value: bool) -> i8 {\n        value as i8\n    }\n}\nimpl From<bool> for i32 {\n    fn from(value: bool) -> i32 {\n        value as i32\n    }\n}\nimpl From<bool> for i64 {\n    fn from(value: bool) -> i64 {\n        value as i64\n    }\n}\nimpl From<bool> for Field {\n    fn from(value: bool) -> Field {\n        value as Field\n    }\n}\n// docs:end:from-impls\n\n/// A generic interface for casting between primitive types,\n/// equivalent of using the `as` keyword between values.\n///\n/// # Example\n///\n/// ```\n/// let x: Field = 1234567890;\n/// let y: u8 = x as u8;\n/// let z: u8 = x.as_();\n/// assert_eq(y, z);\n/// ```\npub trait AsPrimitive<T> {\n    /// The equivalent of doing `self as T`.\n    fn as_(self) -> T;\n}\n\n#[generate_as_primitive_impls]\ncomptime fn generate_as_primitive_impls(_: FunctionDefinition) -> Quoted {\n    let types = [\n        quote { bool },\n        quote { u8 },\n        quote { u16 },\n        quote { u32 },\n        quote { u64 },\n        quote { u128 },\n        quote { i8 },\n        quote { i16 },\n        quote { i32 },\n        quote { i64 },\n        quote { Field },\n    ];\n\n    let mut impls = &[];\n    for type1 in types {\n        for type2 in types {\n            impls = impls.push_back(\n                quote {\n                impl AsPrimitive<$type1> for $type2 {\n                    fn as_(self) -> $type1 {\n                        self as $type1\n                    }\n                }\n            },\n            );\n        }\n    }\n    impls.join(quote {})\n}\n","path":"std/convert.nr"},"18":{"source":"pub mod bn254;\nuse crate::{runtime::is_unconstrained, static_assert};\nuse bn254::lt as bn254_lt;\n\nimpl Field {\n    /// Asserts that `self` can be represented in `bit_size` bits.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^{bit_size}`.\n    // docs:start:assert_max_bit_size\n    pub fn assert_max_bit_size<let BIT_SIZE: u32>(self) {\n        // docs:end:assert_max_bit_size\n        static_assert(\n            BIT_SIZE < modulus_num_bits() as u32,\n            \"BIT_SIZE must be less than modulus_num_bits\",\n        );\n        self.__assert_max_bit_size(BIT_SIZE);\n    }\n\n    #[builtin(apply_range_constraint)]\n    fn __assert_max_bit_size(self, bit_size: u32) {}\n\n    /// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n    /// This slice will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n    /// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n    /// wrap around due to overflow when verifying the decomposition.\n    #[builtin(to_le_bits)]\n    fn _to_le_bits<let N: u32>(self: Self) -> [u1; N] {}\n\n    /// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n    /// This array will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n    /// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n    /// wrap around due to overflow when verifying the decomposition.\n    #[builtin(to_be_bits)]\n    fn _to_be_bits<let N: u32>(self: Self) -> [u1; N] {}\n\n    /// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n    /// This slice will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// The bit decomposition returned is canonical and is guaranteed to not overflow the modulus.\n    // docs:start:to_le_bits\n    pub fn to_le_bits<let N: u32>(self: Self) -> [u1; N] {\n        // docs:end:to_le_bits\n        let bits = self._to_le_bits();\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bits();\n            assert(bits.len() <= p.len());\n            let mut ok = bits.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bits[N - 1 - i] != p[N - 1 - i]) {\n                        assert(p[N - 1 - i] == 1);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bits\n    }\n\n    /// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n    /// This array will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// The bit decomposition returned is canonical and is guaranteed to not overflow the modulus.\n    // docs:start:to_be_bits\n    pub fn to_be_bits<let N: u32>(self: Self) -> [u1; N] {\n        // docs:end:to_be_bits\n        let bits = self._to_be_bits();\n\n        if !is_unconstrained() {\n            // Ensure that the decomposition does not overflow the modulus\n            let p = modulus_be_bits();\n            assert(bits.len() <= p.len());\n            let mut ok = bits.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bits[i] != p[i]) {\n                        assert(p[i] == 1);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bits\n    }\n\n    /// Decomposes `self` into its little endian byte decomposition as a `[u8;N]` array\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_le_bytes\n    pub fn to_le_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_le_bytes\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        // Compute the byte decomposition\n        let bytes = self.to_le_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[N - 1 - i] != p[N - 1 - i]) {\n                        assert(bytes[N - 1 - i] < p[N - 1 - i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    /// Decomposes `self` into its big endian byte decomposition as a `[u8;N]` array of length required to represent the field modulus\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_be_bytes\n    pub fn to_be_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_be_bytes\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        // Compute the byte decomposition\n        let bytes = self.to_be_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_be_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[i] != p[i]) {\n                        assert(bytes[i] < p[i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    // docs:start:to_le_radix\n    pub fn to_le_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            static_assert(1 < radix, \"radix must be greater than 1\");\n            static_assert(radix <= 256, \"radix must be less than or equal to 256\");\n            static_assert(radix & (radix - 1) == 0, \"radix must be a power of 2\");\n        }\n        self.__to_le_radix(radix)\n    }\n    // docs:end:to_le_radix\n\n    // docs:start:to_be_radix\n    pub fn to_be_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            crate::assert_constant(radix);\n        }\n        self.__to_be_radix(radix)\n    }\n    // docs:end:to_be_radix\n\n    // `_radix` must be less than 256\n    #[builtin(to_le_radix)]\n    fn __to_le_radix<let N: u32>(self, radix: u32) -> [u8; N] {}\n\n    // `_radix` must be less than 256\n    #[builtin(to_be_radix)]\n    fn __to_be_radix<let N: u32>(self, radix: u32) -> [u8; N] {}\n\n    // Returns self to the power of the given exponent value.\n    // Caution: we assume the exponent fits into 32 bits\n    // using a bigger bit size impacts negatively the performance and should be done only if the exponent does not fit in 32 bits\n    pub fn pow_32(self, exponent: Field) -> Field {\n        let mut r: Field = 1;\n        let b: [u1; 32] = exponent.to_le_bits();\n\n        for i in 1..33 {\n            r *= r;\n            r = (b[32 - i] as Field) * (r * self) + (1 - b[32 - i] as Field) * r;\n        }\n        r\n    }\n\n    // Parity of (prime) Field element, i.e. sgn0(x mod p) = 0 if x `elem` {0, ..., p-1} is even, otherwise sgn0(x mod p) = 1.\n    pub fn sgn0(self) -> u1 {\n        self as u1\n    }\n\n    pub fn lt(self, another: Field) -> bool {\n        if crate::compat::is_bn254() {\n            bn254_lt(self, another)\n        } else {\n            lt_fallback(self, another)\n        }\n    }\n\n    /// Convert a little endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_le_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n\n    /// Convert a big endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_be_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[N - 1 - i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n}\n\n#[builtin(modulus_num_bits)]\npub comptime fn modulus_num_bits() -> u64 {}\n\n#[builtin(modulus_be_bits)]\npub comptime fn modulus_be_bits() -> [u1] {}\n\n#[builtin(modulus_le_bits)]\npub comptime fn modulus_le_bits() -> [u1] {}\n\n#[builtin(modulus_be_bytes)]\npub comptime fn modulus_be_bytes() -> [u8] {}\n\n#[builtin(modulus_le_bytes)]\npub comptime fn modulus_le_bytes() -> [u8] {}\n\n/// An unconstrained only built in to efficiently compare fields.\n#[builtin(field_less_than)]\nunconstrained fn __field_less_than(x: Field, y: Field) -> bool {}\n\npub(crate) unconstrained fn field_less_than(x: Field, y: Field) -> bool {\n    __field_less_than(x, y)\n}\n\n// Convert a 32 byte array to a field element by modding\npub fn bytes32_to_field(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..16 {\n        high = high + (bytes32[15 - i] as Field) * v;\n        low = low + (bytes32[16 + 15 - i] as Field) * v;\n        v = v * 256;\n    }\n    // Abuse that a % p + b % p = (a + b) % p and that low < p\n    low + high * v\n}\n\nfn lt_fallback(x: Field, y: Field) -> bool {\n    if is_unconstrained() {\n        // Safety: unconstrained context\n        unsafe {\n            field_less_than(x, y)\n        }\n    } else {\n        let x_bytes: [u8; 32] = x.to_le_bytes();\n        let y_bytes: [u8; 32] = y.to_le_bytes();\n        let mut x_is_lt = false;\n        let mut done = false;\n        for i in 0..32 {\n            if (!done) {\n                let x_byte = x_bytes[32 - 1 - i] as u8;\n                let y_byte = y_bytes[32 - 1 - i] as u8;\n                let bytes_match = x_byte == y_byte;\n                if !bytes_match {\n                    x_is_lt = x_byte < y_byte;\n                    done = true;\n                }\n            }\n        }\n        x_is_lt\n    }\n}\n\nmod tests {\n    use crate::{panic::panic, runtime};\n    use super::field_less_than;\n\n    #[test]\n    // docs:start:to_be_bits_example\n    fn test_to_be_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_be_bits();\n        assert_eq(bits, [0, 0, 0, 0, 0, 0, 1, 0]);\n    }\n    // docs:end:to_be_bits_example\n\n    #[test]\n    // docs:start:to_le_bits_example\n    fn test_to_le_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_le_bits();\n        assert_eq(bits, [0, 1, 0, 0, 0, 0, 0, 0]);\n    }\n    // docs:end:to_le_bits_example\n\n    #[test]\n    // docs:start:to_be_bytes_example\n    fn test_to_be_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_be_bytes();\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 0, 2]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_bytes_example\n\n    #[test]\n    // docs:start:to_le_bytes_example\n    fn test_to_le_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_le_bytes();\n        assert_eq(bytes, [2, 0, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_bytes_example\n\n    #[test]\n    // docs:start:to_be_radix_example\n    fn test_to_be_radix() {\n        // 259, in base 256, big endian, is [1, 3].\n        // i.e. 3 * 256^0 + 1 * 256^1\n        let field = 259;\n\n        // The radix (in this example, 256) must be a power of 2.\n        // The length of the returned byte array can be specified to be\n        // >= the amount of space needed.\n        let bytes: [u8; 8] = field.to_be_radix(256);\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 1, 3]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_radix_example\n\n    #[test]\n    // docs:start:to_le_radix_example\n    fn test_to_le_radix() {\n        // 259, in base 256, little endian, is [3, 1].\n        // i.e. 3 * 256^0 + 1 * 256^1\n        let field = 259;\n\n        // The radix (in this example, 256) must be a power of 2.\n        // The length of the returned byte array can be specified to be\n        // >= the amount of space needed.\n        let bytes: [u8; 8] = field.to_le_radix(256);\n        assert_eq(bytes, [3, 1, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_radix_example\n\n    #[test(should_fail_with = \"radix must be greater than 1\")]\n    fn test_to_le_radix_1() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(1);\n        } else {\n            panic(f\"radix must be greater than 1\");\n        }\n    }\n\n    // TODO: Update this test to account for the Brillig restriction that the radix must be greater than 2\n    //#[test]\n    //fn test_to_le_radix_brillig_1() {\n    //    // this test should only fail in constrained mode\n    //    if runtime::is_unconstrained() {\n    //        let field = 1;\n    //        let out: [u8; 8] = field.to_le_radix(1);\n    //        crate::println(out);\n    //        let expected = [0; 8];\n    //        assert(out == expected, \"unexpected result\");\n    //    }\n    //}\n\n    #[test(should_fail_with = \"radix must be a power of 2\")]\n    fn test_to_le_radix_3() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(3);\n        } else {\n            panic(f\"radix must be a power of 2\");\n        }\n    }\n\n    #[test]\n    fn test_to_le_radix_brillig_3() {\n        // this test should only fail in constrained mode\n        if runtime::is_unconstrained() {\n            let field = 1;\n            let out: [u8; 8] = field.to_le_radix(3);\n            let mut expected = [0; 8];\n            expected[0] = 1;\n            assert(out == expected, \"unexpected result\");\n        }\n    }\n\n    #[test(should_fail_with = \"radix must be less than or equal to 256\")]\n    fn test_to_le_radix_512() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(512);\n        } else {\n            panic(f\"radix must be less than or equal to 256\")\n        }\n    }\n\n    // TODO: Update this test to account for the Brillig restriction that the radix must be less than 512\n    //#[test]\n    //fn test_to_le_radix_brillig_512() {\n    //    // this test should only fail in constrained mode\n    //    if runtime::is_unconstrained() {\n    //        let field = 1;\n    //        let out: [u8; 8] = field.to_le_radix(512);\n    //        let mut expected = [0; 8];\n    //        expected[0] = 1;\n    //        assert(out == expected, \"unexpected result\");\n    //    }\n    //}\n\n    #[test]\n    unconstrained fn test_field_less_than() {\n        assert(field_less_than(0, 1));\n        assert(field_less_than(0, 0x100));\n        assert(field_less_than(0x100, 0 - 1));\n        assert(!field_less_than(0 - 1, 0));\n    }\n}\n","path":"std/field/mod.nr"},"19":{"source":"use crate::runtime::is_unconstrained;\n\nglobal BLOCK_SIZE_IN_BYTES: u32 = 136; //(1600 - BITS * 2) / WORD_SIZE;\nglobal WORD_SIZE: u32 = 8; // Limbs are made up of u64s so 8 bytes each.\nglobal LIMBS_PER_BLOCK: u32 = BLOCK_SIZE_IN_BYTES / WORD_SIZE;\nglobal NUM_KECCAK_LANES: u32 = 25;\n\n#[foreign(keccakf1600)]\npub fn keccakf1600(input: [u64; 25]) -> [u64; 25] {}\n\n#[no_predicates]\n#[deprecated(\"keccak256 is being deprecated from the stdlib, use https://github.com/noir-lang/keccak256 instead\")]\npub(crate) fn keccak256<let N: u32>(input: [u8; N], message_size: u32) -> [u8; 32] {\n    assert(N >= message_size);\n\n    // Copy input to block bytes. For that we'll need at least input bytes (N)\n    // but we want it to be padded to a multiple of BLOCK_SIZE_IN_BYTES.\n    let mut block_bytes = [0; ((N / BLOCK_SIZE_IN_BYTES) + 1) * BLOCK_SIZE_IN_BYTES];\n    if is_unconstrained() {\n        for i in 0..message_size {\n            block_bytes[i] = input[i];\n        }\n    } else {\n        for i in 0..N {\n            if i < message_size {\n                block_bytes[i] = input[i];\n            }\n        }\n    }\n\n    //1. format_input_lanes\n    let max_blocks = (N + BLOCK_SIZE_IN_BYTES) / BLOCK_SIZE_IN_BYTES;\n    //maximum number of bytes to hash\n    let real_max_blocks = (message_size + BLOCK_SIZE_IN_BYTES) / BLOCK_SIZE_IN_BYTES;\n    let real_blocks_bytes = real_max_blocks * BLOCK_SIZE_IN_BYTES;\n\n    block_bytes[message_size] = 1;\n    block_bytes[real_blocks_bytes - 1] = 0x80;\n\n    // populate a vector of 64-bit limbs from our byte array\n    let mut sliced_buffer =\n        [0; (((N / BLOCK_SIZE_IN_BYTES) + 1) * BLOCK_SIZE_IN_BYTES) / WORD_SIZE];\n    for i in 0..sliced_buffer.len() {\n        let limb_start = WORD_SIZE * i;\n\n        let mut sliced = 0;\n        let mut v = 1;\n        for k in 0..WORD_SIZE {\n            sliced += v * (block_bytes[limb_start + k] as Field);\n            v *= 256;\n        }\n\n        sliced_buffer[i] = sliced as u64;\n    }\n\n    //2. sponge_absorb\n    let mut state: [u64; NUM_KECCAK_LANES] = [0; NUM_KECCAK_LANES];\n    // When in an unconstrained runtime we can take advantage of runtime loop bounds,\n    // thus allowing us to simplify the loop body.\n    if is_unconstrained() {\n        for i in 0..real_max_blocks {\n            if (i == 0) {\n                for j in 0..LIMBS_PER_BLOCK {\n                    state[j] = sliced_buffer[j];\n                }\n            } else {\n                for j in 0..LIMBS_PER_BLOCK {\n                    state[j] = state[j] ^ sliced_buffer[i * LIMBS_PER_BLOCK + j];\n                }\n            }\n            state = keccakf1600(state);\n        }\n    } else {\n        // `real_max_blocks` is guaranteed to at least be `1`\n        // We peel out the first block as to avoid a conditional inside of the loop.\n        // Otherwise, a dynamic predicate can cause a blowup in a constrained runtime.\n        for j in 0..LIMBS_PER_BLOCK {\n            state[j] = sliced_buffer[j];\n        }\n        state = keccakf1600(state);\n        for i in 1..max_blocks {\n            if i < real_max_blocks {\n                for j in 0..LIMBS_PER_BLOCK {\n                    state[j] = state[j] ^ sliced_buffer[i * LIMBS_PER_BLOCK + j];\n                }\n                state = keccakf1600(state);\n            }\n        }\n    }\n\n    //3. sponge_squeeze\n    let mut result = [0; 32];\n    for i in 0..4 {\n        let lane = state[i] as Field;\n        let lane_le: [u8; 8] = lane.to_le_bytes();\n        for j in 0..8 {\n            result[8 * i + j] = lane_le[j];\n        }\n    }\n    result\n}\n\nmod tests {\n    use super::keccak256;\n\n    #[test]\n    fn smoke_test() {\n        let input = [0xbd];\n        let result = [\n            0x5a, 0x50, 0x2f, 0x9f, 0xca, 0x46, 0x7b, 0x26, 0x6d, 0x5b, 0x78, 0x33, 0x65, 0x19,\n            0x37, 0xe8, 0x05, 0x27, 0x0c, 0xa3, 0xf3, 0xaf, 0x1c, 0x0d, 0xd2, 0x46, 0x2d, 0xca,\n            0x4b, 0x3b, 0x1a, 0xbf,\n        ];\n        assert_eq(keccak256(input, input.len()), result);\n    }\n\n    #[test]\n    fn hash_hello_world() {\n        let input = \"Hello world!\".as_bytes();\n        let result = [\n            0xec, 0xd0, 0xe1, 0x8, 0xa9, 0x8e, 0x19, 0x2a, 0xf1, 0xd2, 0xc2, 0x50, 0x55, 0xf4, 0xe3,\n            0xbe, 0xd7, 0x84, 0xb5, 0xc8, 0x77, 0x20, 0x4e, 0x73, 0x21, 0x9a, 0x52, 0x3, 0x25, 0x1f,\n            0xea, 0xab,\n        ];\n        assert_eq(keccak256(input, input.len()), result);\n    }\n\n    #[test]\n    fn var_size_hash() {\n        let input = [\n            189, 190, 191, 192, 193, 194, 195, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205,\n            206, 207, 208, 209, 210, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222,\n            223,\n        ];\n        let result = [\n            226, 37, 115, 94, 94, 196, 72, 116, 194, 105, 79, 233, 65, 12, 30, 94, 181, 131, 170,\n            219, 171, 166, 236, 88, 143, 67, 255, 160, 248, 214, 39, 129,\n        ];\n        assert_eq(keccak256(input, 13), result);\n    }\n\n    #[test]\n    fn hash_longer_than_136_bytes() {\n        let input = \"123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789\"\n            .as_bytes();\n        assert(input.len() > 136);\n\n        let result = [\n            0x1d, 0xca, 0xeb, 0xdf, 0xd9, 0xd6, 0x24, 0x67, 0x1c, 0x18, 0x16, 0xda, 0xd, 0x8a, 0xeb,\n            0xa8, 0x75, 0x71, 0x2c, 0xc, 0x89, 0xe0, 0x25, 0x2, 0xe8, 0xb6, 0x5e, 0x16, 0x5, 0x55,\n            0xe4, 0x40,\n        ];\n        assert_eq(keccak256(input, input.len()), result);\n    }\n}\n","path":"std/hash/keccak.nr"},"20":{"source":"pub mod poseidon;\npub mod poseidon2;\npub mod keccak;\npub mod sha256;\npub mod sha512;\n\nuse crate::default::Default;\nuse crate::embedded_curve_ops::{\n    EmbeddedCurvePoint, EmbeddedCurveScalar, multi_scalar_mul, multi_scalar_mul_array_return,\n};\nuse crate::meta::derive_via;\nuse crate::uint128::U128;\n\n// Kept for backwards compatibility\npub use sha256::{digest, sha256, sha256_compression, sha256_var};\n\n#[foreign(blake2s)]\n// docs:start:blake2s\npub fn blake2s<let N: u32>(input: [u8; N]) -> [u8; 32]\n// docs:end:blake2s\n{}\n\n#[foreign(blake3)]\n// docs:start:blake3\npub fn blake3<let N: u32>(input: [u8; N]) -> [u8; 32]\n// docs:end:blake3\n{}\n\n// docs:start:pedersen_commitment\npub fn pedersen_commitment<let N: u32>(input: [Field; N]) -> EmbeddedCurvePoint {\n    // docs:end:pedersen_commitment\n    pedersen_commitment_with_separator(input, 0)\n}\n\n#[inline_always]\npub fn pedersen_commitment_with_separator<let N: u32>(\n    input: [Field; N],\n    separator: u32,\n) -> EmbeddedCurvePoint {\n    let mut points = [EmbeddedCurveScalar { lo: 0, hi: 0 }; N];\n    for i in 0..N {\n        // we use the unsafe version because the multi_scalar_mul will constrain the scalars.\n        points[i] = from_field_unsafe(input[i]);\n    }\n    let generators = derive_generators(\"DEFAULT_DOMAIN_SEPARATOR\".as_bytes(), separator);\n    multi_scalar_mul(generators, points)\n}\n\n// docs:start:pedersen_hash\npub fn pedersen_hash<let N: u32>(input: [Field; N]) -> Field\n// docs:end:pedersen_hash\n{\n    pedersen_hash_with_separator(input, 0)\n}\n\n#[no_predicates]\npub fn pedersen_hash_with_separator<let N: u32>(input: [Field; N], separator: u32) -> Field {\n    let mut scalars: [EmbeddedCurveScalar; N + 1] = [EmbeddedCurveScalar { lo: 0, hi: 0 }; N + 1];\n    let mut generators: [EmbeddedCurvePoint; N + 1] =\n        [EmbeddedCurvePoint::point_at_infinity(); N + 1];\n    let domain_generators: [EmbeddedCurvePoint; N] =\n        derive_generators(\"DEFAULT_DOMAIN_SEPARATOR\".as_bytes(), separator);\n\n    for i in 0..N {\n        scalars[i] = from_field_unsafe(input[i]);\n        generators[i] = domain_generators[i];\n    }\n    scalars[N] = EmbeddedCurveScalar { lo: N as Field, hi: 0 as Field };\n\n    let length_generator: [EmbeddedCurvePoint; 1] =\n        derive_generators(\"pedersen_hash_length\".as_bytes(), 0);\n    generators[N] = length_generator[0];\n    multi_scalar_mul_array_return(generators, scalars)[0]\n}\n\n#[field(bn254)]\n#[inline_always]\npub fn derive_generators<let N: u32, let M: u32>(\n    domain_separator_bytes: [u8; M],\n    starting_index: u32,\n) -> [EmbeddedCurvePoint; N] {\n    crate::assert_constant(domain_separator_bytes);\n    // TODO(https://github.com/noir-lang/noir/issues/5672): Add back assert_constant on starting_index\n    __derive_generators(domain_separator_bytes, starting_index)\n}\n\n#[builtin(derive_pedersen_generators)]\n#[field(bn254)]\nfn __derive_generators<let N: u32, let M: u32>(\n    domain_separator_bytes: [u8; M],\n    starting_index: u32,\n) -> [EmbeddedCurvePoint; N] {}\n\n#[field(bn254)]\n// Same as from_field but:\n// does not assert the limbs are 128 bits\n// does not assert the decomposition does not overflow the EmbeddedCurveScalar\nfn from_field_unsafe(scalar: Field) -> EmbeddedCurveScalar {\n    // Safety: xlo and xhi decomposition is checked below\n    let (xlo, xhi) = unsafe { crate::field::bn254::decompose_hint(scalar) };\n    // Check that the decomposition is correct\n    assert_eq(scalar, xlo + crate::field::bn254::TWO_POW_128 * xhi);\n    EmbeddedCurveScalar { lo: xlo, hi: xhi }\n}\n\npub fn hash_to_field(inputs: [Field]) -> Field {\n    let mut sum = 0;\n\n    for input in inputs {\n        let input_bytes: [u8; 32] = input.to_le_bytes();\n        sum += crate::field::bytes32_to_field(blake2s(input_bytes));\n    }\n\n    sum\n}\n\n// docs:start:keccak256\npub fn keccak256<let N: u32>(input: [u8; N], message_size: u32) -> [u8; 32]\n// docs:end:keccak256\n{\n    crate::hash::keccak::keccak256(input, message_size)\n}\n\n#[foreign(poseidon2_permutation)]\npub fn poseidon2_permutation<let N: u32>(_input: [Field; N], _state_length: u32) -> [Field; N] {}\n\n// Generic hashing support.\n// Partially ported and impacted by rust.\n\n// Hash trait shall be implemented per type.\n#[derive_via(derive_hash)]\npub trait Hash {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher;\n}\n\n// docs:start:derive_hash\ncomptime fn derive_hash(s: StructDefinition) -> Quoted {\n    let name = quote { Hash };\n    let signature = quote { fn hash<H>(_self: Self, _state: &mut H) where H: std::hash::Hasher };\n    let for_each_field = |name| quote { _self.$name.hash(_state); };\n    crate::meta::make_trait_impl(\n        s,\n        name,\n        signature,\n        for_each_field,\n        quote {},\n        |fields| fields,\n    )\n}\n// docs:end:derive_hash\n\n// Hasher trait shall be implemented by algorithms to provide hash-agnostic means.\n// TODO: consider making the types generic here ([u8], [Field], etc.)\npub trait Hasher {\n    fn finish(self) -> Field;\n\n    fn write(&mut self, input: Field);\n}\n\n// BuildHasher is a factory trait, responsible for production of specific Hasher.\npub trait BuildHasher<H>\nwhere\n    H: Hasher,\n{\n    fn build_hasher(self) -> H;\n}\n\npub struct BuildHasherDefault<H>;\n\nimpl<H> BuildHasher<H> for BuildHasherDefault<H>\nwhere\n    H: Hasher + Default,\n{\n    fn build_hasher(_self: Self) -> H {\n        H::default()\n    }\n}\n\nimpl<H> Default for BuildHasherDefault<H>\nwhere\n    H: Hasher + Default,\n{\n    fn default() -> Self {\n        BuildHasherDefault {}\n    }\n}\n\nimpl Hash for Field {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self);\n    }\n}\n\nimpl Hash for u1 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u8 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u16 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u32 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u64 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u128 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i8 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i16 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i32 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i64 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for bool {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for () {\n    fn hash<H>(_self: Self, _state: &mut H)\n    where\n        H: Hasher,\n    {}\n}\n\nimpl Hash for U128 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self.lo as Field);\n        H::write(state, self.hi as Field);\n    }\n}\n\nimpl<T, let N: u32> Hash for [T; N]\nwhere\n    T: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        for elem in self {\n            elem.hash(state);\n        }\n    }\n}\n\nimpl<T> Hash for [T]\nwhere\n    T: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.len().hash(state);\n        for elem in self {\n            elem.hash(state);\n        }\n    }\n}\n\nimpl<A, B> Hash for (A, B)\nwhere\n    A: Hash,\n    B: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n    }\n}\n\nimpl<A, B, C> Hash for (A, B, C)\nwhere\n    A: Hash,\n    B: Hash,\n    C: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n    }\n}\n\nimpl<A, B, C, D> Hash for (A, B, C, D)\nwhere\n    A: Hash,\n    B: Hash,\n    C: Hash,\n    D: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n        self.3.hash(state);\n    }\n}\n\nimpl<A, B, C, D, E> Hash for (A, B, C, D, E)\nwhere\n    A: Hash,\n    B: Hash,\n    C: Hash,\n    D: Hash,\n    E: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n        self.3.hash(state);\n        self.4.hash(state);\n    }\n}\n\n// Some test vectors for Pedersen hash and Pedersen Commitment.\n// They have been generated using the same functions so the tests are for now useless\n// but they will be useful when we switch to Noir implementation.\n#[test]\nfn assert_pedersen() {\n    assert_eq(\n        pedersen_hash_with_separator([1], 1),\n        0x1b3f4b1a83092a13d8d1a59f7acb62aba15e7002f4440f2275edb99ebbc2305f,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1], 1),\n        EmbeddedCurvePoint {\n            x: 0x054aa86a73cb8a34525e5bbed6e43ba1198e860f5f3950268f71df4591bde402,\n            y: 0x209dcfbf2cfb57f9f6046f44d71ac6faf87254afc7407c04eb621a6287cac126,\n            is_infinite: false,\n        },\n    );\n\n    assert_eq(\n        pedersen_hash_with_separator([1, 2], 2),\n        0x26691c129448e9ace0c66d11f0a16d9014a9e8498ee78f4d69f0083168188255,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2], 2),\n        EmbeddedCurvePoint {\n            x: 0x2e2b3b191e49541fe468ec6877721d445dcaffe41728df0a0eafeb15e87b0753,\n            y: 0x2ff4482400ad3a6228be17a2af33e2bcdf41be04795f9782bd96efe7e24f8778,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3], 3),\n        0x0bc694b7a1f8d10d2d8987d07433f26bd616a2d351bc79a3c540d85b6206dbe4,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3], 3),\n        EmbeddedCurvePoint {\n            x: 0x1fee4e8cf8d2f527caa2684236b07c4b1bad7342c01b0f75e9a877a71827dc85,\n            y: 0x2f9fedb9a090697ab69bf04c8bc15f7385b3e4b68c849c1536e5ae15ff138fd1,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4], 4),\n        0xdae10fb32a8408521803905981a2b300d6a35e40e798743e9322b223a5eddc,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4], 4),\n        EmbeddedCurvePoint {\n            x: 0x07ae3e202811e1fca39c2d81eabe6f79183978e6f12be0d3b8eda095b79bdbc9,\n            y: 0x0afc6f892593db6fbba60f2da558517e279e0ae04f95758587760ba193145014,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5], 5),\n        0xfc375b062c4f4f0150f7100dfb8d9b72a6d28582dd9512390b0497cdad9c22,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5], 5),\n        EmbeddedCurvePoint {\n            x: 0x1754b12bd475a6984a1094b5109eeca9838f4f81ac89c5f0a41dbce53189bb29,\n            y: 0x2da030e3cfcdc7ddad80eaf2599df6692cae0717d4e9f7bfbee8d073d5d278f7,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6], 6),\n        0x1696ed13dc2730062a98ac9d8f9de0661bb98829c7582f699d0273b18c86a572,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6], 6),\n        EmbeddedCurvePoint {\n            x: 0x190f6c0e97ad83e1e28da22a98aae156da083c5a4100e929b77e750d3106a697,\n            y: 0x1f4b60f34ef91221a0b49756fa0705da93311a61af73d37a0c458877706616fb,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7], 7),\n        0x128c0ff144fc66b6cb60eeac8a38e23da52992fc427b92397a7dffd71c45ede3,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7], 7),\n        EmbeddedCurvePoint {\n            x: 0x015441e9d29491b06563fac16fc76abf7a9534c715421d0de85d20dbe2965939,\n            y: 0x1d2575b0276f4e9087e6e07c2cb75aa1baafad127af4be5918ef8a2ef2fea8fc,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8], 8),\n        0x2f960e117482044dfc99d12fece2ef6862fba9242be4846c7c9a3e854325a55c,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8], 8),\n        EmbeddedCurvePoint {\n            x: 0x1657737676968887fceb6dd516382ea13b3a2c557f509811cd86d5d1199bc443,\n            y: 0x1f39f0cb569040105fa1e2f156521e8b8e08261e635a2b210bdc94e8d6d65f77,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9], 9),\n        0x0c96db0790602dcb166cc4699e2d306c479a76926b81c2cb2aaa92d249ec7be7,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9], 9),\n        EmbeddedCurvePoint {\n            x: 0x0a3ceae42d14914a432aa60ec7fded4af7dad7dd4acdbf2908452675ec67e06d,\n            y: 0xfc19761eaaf621ad4aec9a8b2e84a4eceffdba78f60f8b9391b0bd9345a2f2,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 10),\n        0x2cd37505871bc460a62ea1e63c7fe51149df5d0801302cf1cbc48beb8dff7e94,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 10),\n        EmbeddedCurvePoint {\n            x: 0x2fb3f8b3d41ddde007c8c3c62550f9a9380ee546fcc639ffbb3fd30c8d8de30c,\n            y: 0x300783be23c446b11a4c0fabf6c91af148937cea15fcf5fb054abf7f752ee245,\n            is_infinite: false,\n        },\n    );\n}\n","path":"std/hash/mod.nr"},"29":{"source":"pub mod hash;\npub mod aes128;\npub mod array;\npub mod slice;\npub mod merkle;\npub mod ecdsa_secp256k1;\npub mod ecdsa_secp256r1;\npub mod embedded_curve_ops;\npub mod sha256;\npub mod sha512;\npub mod field;\npub mod collections;\npub mod compat;\npub mod convert;\npub mod option;\npub mod string;\npub mod test;\npub mod cmp;\npub mod ops;\npub mod default;\npub mod prelude;\npub mod uint128;\npub mod runtime;\npub mod meta;\npub mod append;\npub mod mem;\npub mod panic;\npub mod hint;\n\nuse convert::AsPrimitive;\n\n// Oracle calls are required to be wrapped in an unconstrained function\n// Thus, the only argument to the `println` oracle is expected to always be an ident\n#[oracle(print)]\nunconstrained fn print_oracle<T>(with_newline: bool, input: T) {}\n\nunconstrained fn print_unconstrained<T>(with_newline: bool, input: T) {\n    print_oracle(with_newline, input);\n}\n\npub fn println<T>(input: T) {\n    // Safety: a print statement cannot be constrained\n    unsafe {\n        print_unconstrained(true, input);\n    }\n}\n\npub fn print<T>(input: T) {\n    // Safety: a print statement cannot be constrained\n    unsafe {\n        print_unconstrained(false, input);\n    }\n}\n\npub fn verify_proof<let N: u32, let M: u32, let K: u32>(\n    verification_key: [Field; N],\n    proof: [Field; M],\n    public_inputs: [Field; K],\n    key_hash: Field,\n) {\n    verify_proof_internal(verification_key, proof, public_inputs, key_hash, 0);\n}\n\npub fn verify_proof_with_type<let N: u32, let M: u32, let K: u32>(\n    verification_key: [Field; N],\n    proof: [Field; M],\n    public_inputs: [Field; K],\n    key_hash: Field,\n    proof_type: u32,\n) {\n    if !crate::runtime::is_unconstrained() {\n        crate::assert_constant(proof_type);\n    }\n    verify_proof_internal(verification_key, proof, public_inputs, key_hash, proof_type);\n}\n\n#[foreign(recursive_aggregation)]\nfn verify_proof_internal<let N: u32, let M: u32, let K: u32>(\n    verification_key: [Field; N],\n    proof: [Field; M],\n    public_inputs: [Field; K],\n    key_hash: Field,\n    proof_type: u32,\n) {}\n\n// Asserts that the given value is known at compile-time.\n// Useful for debugging for-loop bounds.\n#[builtin(assert_constant)]\npub fn assert_constant<T>(x: T) {}\n\n// Asserts that the given value is both true and known at compile-time\n#[builtin(static_assert)]\npub fn static_assert<let N: u32>(predicate: bool, message: str<N>) {}\n\npub fn wrapping_add<T>(x: T, y: T) -> T\nwhere\n    T: AsPrimitive<Field>,\n    Field: AsPrimitive<T>,\n{\n    AsPrimitive::as_(x.as_() + y.as_())\n}\n\npub fn wrapping_sub<T>(x: T, y: T) -> T\nwhere\n    T: AsPrimitive<Field>,\n    Field: AsPrimitive<T>,\n{\n    //340282366920938463463374607431768211456 is 2^128, it is used to avoid underflow\n    AsPrimitive::as_(x.as_() + 340282366920938463463374607431768211456 - y.as_())\n}\n\npub fn wrapping_mul<T>(x: T, y: T) -> T\nwhere\n    T: AsPrimitive<Field>,\n    Field: AsPrimitive<T>,\n{\n    AsPrimitive::as_(x.as_() * y.as_())\n}\n\n#[builtin(as_witness)]\npub fn as_witness(x: Field) {}\n\nmod tests {\n    #[test(should_fail_with = \"custom message\")]\n    fn test_static_assert_custom_message() {\n        super::static_assert(1 == 2, \"custom message\");\n    }\n}\n","path":"std/lib.nr"},"59":{"source":"use crate::cmp::{Eq, Ord, Ordering};\nuse crate::ops::{Add, BitAnd, BitOr, BitXor, Div, Mul, Not, Rem, Shl, Shr, Sub};\nuse crate::static_assert;\nuse super::{convert::AsPrimitive, default::Default};\n\nglobal pow64: Field = 18446744073709551616; //2^64;\nglobal pow63: Field = 9223372036854775808; // 2^63;\npub struct U128 {\n    pub(crate) lo: Field,\n    pub(crate) hi: Field,\n}\n\nimpl U128 {\n\n    pub fn from_u64s_le(lo: u64, hi: u64) -> U128 {\n        // in order to handle multiplication, we need to represent the product of two u64 without overflow\n        assert(crate::field::modulus_num_bits() as u32 > 128);\n        U128 { lo: lo as Field, hi: hi as Field }\n    }\n\n    pub fn from_u64s_be(hi: u64, lo: u64) -> U128 {\n        U128::from_u64s_le(lo, hi)\n    }\n\n    pub fn zero() -> U128 {\n        U128 { lo: 0, hi: 0 }\n    }\n\n    pub fn one() -> U128 {\n        U128 { lo: 1, hi: 0 }\n    }\n    pub fn from_le_bytes(bytes: [u8; 16]) -> U128 {\n        let mut lo = 0;\n        let mut base = 1;\n        for i in 0..8 {\n            lo += (bytes[i] as Field) * base;\n            base *= 256;\n        }\n        let mut hi = 0;\n        base = 1;\n        for i in 8..16 {\n            hi += (bytes[i] as Field) * base;\n            base *= 256;\n        }\n        U128 { lo, hi }\n    }\n\n    pub fn to_be_bytes(self: Self) -> [u8; 16] {\n        let lo: [u8; 8] = self.lo.to_be_bytes();\n        let hi: [u8; 8] = self.hi.to_be_bytes();\n        let mut bytes = [0; 16];\n        for i in 0..8 {\n            bytes[i] = hi[i];\n            bytes[i + 8] = lo[i];\n        }\n        bytes\n    }\n\n    pub fn to_le_bytes(self: Self) -> [u8; 16] {\n        let lo: [u8; 8] = self.lo.to_le_bytes();\n        let hi: [u8; 8] = self.hi.to_le_bytes();\n        let mut bytes = [0; 16];\n        for i in 0..8 {\n            bytes[i] = lo[i];\n            bytes[i + 8] = hi[i];\n        }\n        bytes\n    }\n\n    pub fn from_hex<let N: u32>(hex: str<N>) -> U128 {\n        let bytes = hex.as_bytes();\n        // string must starts with \"0x\"\n        assert((bytes[0] == 48) & (bytes[1] == 120), \"Invalid hexadecimal string\");\n        static_assert(N < 35, \"Input does not fit into a U128\");\n\n        let mut lo = 0;\n        let mut hi = 0;\n        let mut base = 1;\n        if N <= 18 {\n            for i in 0..N - 2 {\n                lo += U128::decode_ascii(bytes[N - i - 1]) * base;\n                base = base * 16;\n            }\n        } else {\n            for i in 0..16 {\n                lo += U128::decode_ascii(bytes[N - i - 1]) * base;\n                base = base * 16;\n            }\n            base = 1;\n            for i in 17..N - 1 {\n                hi += U128::decode_ascii(bytes[N - i]) * base;\n                base = base * 16;\n            }\n        }\n        U128 { lo: lo as Field, hi: hi as Field }\n    }\n\n    unconstrained fn unconstrained_check_is_upper_ascii(ascii: u8) -> bool {\n        ((ascii >= 65) & (ascii <= 90)) // Between 'A' and 'Z'\n    }\n\n    pub(crate) fn decode_ascii(ascii: u8) -> Field {\n        (\n            if ascii < 58 {\n                ascii - 48\n            } else {\n                // Safety: optionally adds 32 and then check (below) the result is in 'a..f' range\n                let ascii =\n                    ascii + 32 * (unsafe { U128::unconstrained_check_is_upper_ascii(ascii) as u8 });\n                assert(ascii >= 97); // enforce >= 'a'\n                assert(ascii <= 102); // enforce <= 'f'\n                ascii - 87\n            }\n        ) as Field\n    }\n\n    // TODO: Replace with a faster version.\n    // A circuit that uses this function can be slow to compute\n    // (we're doing up to 127 calls to compute the quotient)\n    unconstrained fn unconstrained_div(self: Self, b: U128) -> (U128, U128) {\n        if b == U128::zero() {\n            // Return 0,0 to avoid eternal loop\n            (U128::zero(), U128::zero())\n        } else if self < b {\n            (U128::zero(), self)\n        } else if self == b {\n            (U128::one(), U128::zero())\n        } else {\n            let (q, r) = if b.hi as u64 >= pow63 as u64 {\n                // The result of multiplication by 2 would overflow\n                (U128::zero(), self)\n            } else {\n                self.unconstrained_div(b * U128::from_u64s_le(2, 0))\n            };\n            let q_mul_2 = q * U128::from_u64s_le(2, 0);\n            if r < b {\n                (q_mul_2, r)\n            } else {\n                (q_mul_2 + U128::one(), r - b)\n            }\n        }\n    }\n\n    pub fn from_integer<T>(i: T) -> U128\n    where\n        T: AsPrimitive<Field>,\n    {\n        let f = i.as_();\n        // Reject values which would overflow a u128\n        f.assert_max_bit_size::<128>();\n        let lo = f as u64 as Field;\n        let hi = (f - lo) / pow64;\n        U128 { lo, hi }\n    }\n\n    pub fn to_integer<T>(self) -> T\n    where\n        Field: AsPrimitive<T>,\n    {\n        AsPrimitive::as_(self.lo + self.hi * pow64)\n    }\n\n    fn wrapping_mul(self: Self, b: U128) -> U128 {\n        let low = self.lo * b.lo;\n        let lo = low as u64 as Field;\n        let carry = (low - lo) / pow64;\n        let high = self.lo * b.hi + self.hi * b.lo + carry;\n        let hi = high as u64 as Field;\n        U128 { lo, hi }\n    }\n}\n\nimpl Add for U128 {\n    fn add(self: Self, b: U128) -> U128 {\n        let low = self.lo + b.lo;\n        let lo = low as u64 as Field;\n        let carry = (low - lo) / pow64;\n        let high = self.hi + b.hi + carry;\n        let hi = high as u64 as Field;\n        assert(hi == high, \"attempt to add with overflow\");\n        U128 { lo, hi }\n    }\n}\n\nimpl Sub for U128 {\n    fn sub(self: Self, b: U128) -> U128 {\n        let low = pow64 + self.lo - b.lo;\n        let lo = low as u64 as Field;\n        let borrow = (low == lo) as Field;\n        let high = self.hi - b.hi - borrow;\n        let hi = high as u64 as Field;\n        assert(hi == high, \"attempt to subtract with underflow\");\n        U128 { lo, hi }\n    }\n}\n\nimpl Mul for U128 {\n    fn mul(self: Self, b: U128) -> U128 {\n        assert(self.hi * b.hi == 0, \"attempt to multiply with overflow\");\n        let low = self.lo * b.lo;\n        let lo = low as u64 as Field;\n        let carry = (low - lo) / pow64;\n        let high = if crate::field::modulus_num_bits() as u32 > 196 {\n            (self.lo + self.hi) * (b.lo + b.hi) - low + carry\n        } else {\n            self.lo * b.hi + self.hi * b.lo + carry\n        };\n        let hi = high as u64 as Field;\n        assert(hi == high, \"attempt to multiply with overflow\");\n        U128 { lo, hi }\n    }\n}\n\nimpl Div for U128 {\n    fn div(self: Self, b: U128) -> U128 {\n        // Safety: euclidian division is asserted to be correct: assert(a == b * q + r); and assert(r < b);\n        // Furthermore, U128 addition and multiplication ensures that b * q + r does not overflow\n        unsafe {\n            let (q, r) = self.unconstrained_div(b);\n            let a = b * q + r;\n            assert_eq(self, a);\n            assert(r < b);\n            q\n        }\n    }\n}\n\nimpl Rem for U128 {\n    fn rem(self: Self, b: U128) -> U128 {\n        // Safety: cf div() above\n        unsafe {\n            let (q, r) = self.unconstrained_div(b);\n            let a = b * q + r;\n            assert_eq(self, a);\n            assert(r < b);\n\n            r\n        }\n    }\n}\n\nimpl Eq for U128 {\n    fn eq(self: Self, b: U128) -> bool {\n        (self.lo == b.lo) & (self.hi == b.hi)\n    }\n}\n\nimpl Ord for U128 {\n    fn cmp(self, other: Self) -> Ordering {\n        let hi_ordering = (self.hi as u64).cmp((other.hi as u64));\n        let lo_ordering = (self.lo as u64).cmp((other.lo as u64));\n\n        if hi_ordering == Ordering::equal() {\n            lo_ordering\n        } else {\n            hi_ordering\n        }\n    }\n}\n\nimpl Not for U128 {\n    fn not(self) -> U128 {\n        U128 { lo: (!(self.lo as u64)) as Field, hi: (!(self.hi as u64)) as Field }\n    }\n}\n\nimpl BitOr for U128 {\n    fn bitor(self, other: U128) -> U128 {\n        U128 {\n            lo: ((self.lo as u64) | (other.lo as u64)) as Field,\n            hi: ((self.hi as u64) | (other.hi as u64)) as Field,\n        }\n    }\n}\n\nimpl BitAnd for U128 {\n    fn bitand(self, other: U128) -> U128 {\n        U128 {\n            lo: ((self.lo as u64) & (other.lo as u64)) as Field,\n            hi: ((self.hi as u64) & (other.hi as u64)) as Field,\n        }\n    }\n}\n\nimpl BitXor for U128 {\n    fn bitxor(self, other: U128) -> U128 {\n        U128 {\n            lo: ((self.lo as u64) ^ (other.lo as u64)) as Field,\n            hi: ((self.hi as u64) ^ (other.hi as u64)) as Field,\n        }\n    }\n}\n\nimpl Shl for U128 {\n    fn shl(self, other: u8) -> U128 {\n        assert(other < 128, \"attempt to shift left with overflow\");\n        let exp_bits: [u1; 7] = (other as Field).to_be_bits();\n\n        let mut r: Field = 2;\n        let mut y: Field = 1;\n        for i in 1..8 {\n            let bit = exp_bits[7 - i] as Field;\n            y = bit * (r * y) + (1 - bit) * y;\n            r *= r;\n        }\n        self.wrapping_mul(U128::from_integer(y))\n    }\n}\n\nimpl Shr for U128 {\n    fn shr(self, other: u8) -> U128 {\n        assert(other < 128, \"attempt to shift right with overflow\");\n        let exp_bits: [u1; 7] = (other as Field).to_be_bits();\n\n        let mut r: Field = 2;\n        let mut y: Field = 1;\n        for i in 1..8 {\n            let bit = exp_bits[7 - i] as Field;\n            y = bit * (r * y) + (1 - bit) * y;\n            r *= r;\n        }\n        self / U128::from_integer(y)\n    }\n}\n\nimpl Default for U128 {\n    fn default() -> Self {\n        U128::zero()\n    }\n}\n\nmod tests {\n    use crate::default::Default;\n    use crate::ops::Not;\n    use crate::uint128::{pow63, pow64, U128};\n\n    #[test]\n    fn test_not(lo: u64, hi: u64) {\n        let num = U128::from_u64s_le(lo, hi);\n        let not_num = num.not();\n\n        assert_eq(not_num.hi, (hi.not() as Field));\n        assert_eq(not_num.lo, (lo.not() as Field));\n\n        let not_not_num = not_num.not();\n        assert_eq(num, not_not_num);\n    }\n    #[test]\n    fn test_construction() {\n        // Check little-endian u64 is inversed with big-endian u64 construction\n        let a = U128::from_u64s_le(2, 1);\n        let b = U128::from_u64s_be(1, 2);\n        assert_eq(a, b);\n        // Check byte construction is equivalent\n        let c = U128::from_le_bytes([0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15]);\n        let d = U128::from_u64s_le(0x0706050403020100, 0x0f0e0d0c0b0a0908);\n        assert_eq(c, d);\n    }\n    #[test]\n    fn test_byte_decomposition() {\n        let a = U128::from_u64s_le(0x0706050403020100, 0x0f0e0d0c0b0a0908);\n        // Get big-endian and little-endian byte decompostions\n        let le_bytes_a = a.to_le_bytes();\n        let be_bytes_a = a.to_be_bytes();\n\n        // Check equivalence\n        for i in 0..16 {\n            assert_eq(le_bytes_a[i], be_bytes_a[15 - i]);\n        }\n        // Reconstruct U128 from byte decomposition\n        let b = U128::from_le_bytes(le_bytes_a);\n        // Check that it's the same element\n        assert_eq(a, b);\n    }\n    #[test]\n    fn test_hex_constuction() {\n        let a = U128::from_u64s_le(0x1, 0x2);\n        let b = U128::from_hex(\"0x20000000000000001\");\n        assert_eq(a, b);\n\n        let c = U128::from_hex(\"0xffffffffffffffffffffffffffffffff\");\n        let d = U128::from_u64s_le(0xffffffffffffffff, 0xffffffffffffffff);\n        assert_eq(c, d);\n\n        let e = U128::from_hex(\"0x00000000000000000000000000000000\");\n        let f = U128::from_u64s_le(0, 0);\n        assert_eq(e, f);\n    }\n\n    // Ascii decode tests\n\n    #[test]\n    fn test_ascii_decode_correct_range() {\n        // '0'..'9' range\n        for i in 0..10 {\n            let decoded = U128::decode_ascii(48 + i);\n            assert_eq(decoded, i as Field);\n        }\n        // 'A'..'F' range\n        for i in 0..6 {\n            let decoded = U128::decode_ascii(65 + i);\n            assert_eq(decoded, (i + 10) as Field);\n        }\n        // 'a'..'f' range\n        for i in 0..6 {\n            let decoded = U128::decode_ascii(97 + i);\n            assert_eq(decoded, (i + 10) as Field);\n        }\n    }\n\n    #[test(should_fail)]\n    fn test_ascii_decode_range_less_than_48_fails_0() {\n        crate::println(U128::decode_ascii(0));\n    }\n    #[test(should_fail)]\n    fn test_ascii_decode_range_less_than_48_fails_1() {\n        crate::println(U128::decode_ascii(47));\n    }\n\n    #[test(should_fail)]\n    fn test_ascii_decode_range_58_64_fails_0() {\n        let _ = U128::decode_ascii(58);\n    }\n    #[test(should_fail)]\n    fn test_ascii_decode_range_58_64_fails_1() {\n        let _ = U128::decode_ascii(64);\n    }\n    #[test(should_fail)]\n    fn test_ascii_decode_range_71_96_fails_0() {\n        let _ = U128::decode_ascii(71);\n    }\n    #[test(should_fail)]\n    fn test_ascii_decode_range_71_96_fails_1() {\n        let _ = U128::decode_ascii(96);\n    }\n    #[test(should_fail)]\n    fn test_ascii_decode_range_greater_than_102_fails() {\n        let _ = U128::decode_ascii(103);\n    }\n\n    #[test(should_fail)]\n    fn test_ascii_decode_regression() {\n        // This code will actually fail because of ascii_decode,\n        // but in the past it was possible to create a value > (1<<128)\n        let a = U128::from_hex(\"0x~fffffffffffffffffffffffffffffff\");\n        let b: Field = a.to_integer();\n        let c: [u8; 17] = b.to_le_bytes();\n        assert(c[16] != 0);\n    }\n\n    #[test]\n    fn test_unconstrained_div() {\n        // Test the potential overflow case\n        let a = U128::from_u64s_le(0x0, 0xffffffffffffffff);\n        let b = U128::from_u64s_le(0x0, 0xfffffffffffffffe);\n        let c = U128::one();\n        let d = U128::from_u64s_le(0x0, 0x1);\n        // Safety: testing context\n        unsafe {\n            let (q, r) = a.unconstrained_div(b);\n            assert_eq(q, c);\n            assert_eq(r, d);\n        }\n\n        let a = U128::from_u64s_le(2, 0);\n        let b = U128::one();\n        // Check the case where a is a multiple of b\n        // Safety: testing context\n        unsafe {\n            let (c, d) = a.unconstrained_div(b);\n            assert_eq((c, d), (a, U128::zero()));\n        }\n\n        // Check where b is a multiple of a\n        // Safety: testing context\n        unsafe {\n            let (c, d) = b.unconstrained_div(a);\n            assert_eq((c, d), (U128::zero(), b));\n        }\n\n        // Dividing by zero returns 0,0\n        let a = U128::from_u64s_le(0x1, 0x0);\n        let b = U128::zero();\n        // Safety: testing context\n        unsafe {\n            let (c, d) = a.unconstrained_div(b);\n            assert_eq((c, d), (U128::zero(), U128::zero()));\n        }\n        // Dividing 1<<127 by 1<<127 (special case)\n        let a = U128::from_u64s_le(0x0, pow63 as u64);\n        let b = U128::from_u64s_le(0x0, pow63 as u64);\n        // Safety: testing context\n        unsafe {\n            let (c, d) = a.unconstrained_div(b);\n            assert_eq((c, d), (U128::one(), U128::zero()));\n        }\n    }\n\n    #[test]\n    fn integer_conversions() {\n        // Maximum\n        let start: Field = 0xffffffffffffffffffffffffffffffff;\n        let a = U128::from_integer(start);\n        let end = a.to_integer();\n        assert_eq(start, end);\n\n        // Minimum\n        let start: Field = 0x0;\n        let a = U128::from_integer(start);\n        let end = a.to_integer();\n        assert_eq(start, end);\n\n        // Low limb\n        let start: Field = 0xffffffffffffffff;\n        let a = U128::from_integer(start);\n        let end = a.to_integer();\n        assert_eq(start, end);\n\n        // High limb\n        let start: Field = 0xffffffffffffffff0000000000000000;\n        let a = U128::from_integer(start);\n        let end = a.to_integer();\n        assert_eq(start, end);\n    }\n\n    #[test]\n    fn integer_conversions_fuzz(lo: u64, hi: u64) {\n        let start: Field = (lo as Field) + pow64 * (hi as Field);\n        let a = U128::from_integer(start);\n        let end = a.to_integer();\n        assert_eq(start, end);\n    }\n\n    #[test]\n    fn test_wrapping_mul() {\n        // 1*0==0\n        assert_eq(U128::zero(), U128::zero().wrapping_mul(U128::one()));\n\n        // 0*1==0\n        assert_eq(U128::zero(), U128::one().wrapping_mul(U128::zero()));\n\n        // 1*1==1\n        assert_eq(U128::one(), U128::one().wrapping_mul(U128::one()));\n\n        // 0 * ( 1 << 64 ) ==  0\n        assert_eq(U128::zero(), U128::zero().wrapping_mul(U128::from_u64s_le(0, 1)));\n\n        // ( 1 << 64 ) * 0 == 0\n        assert_eq(U128::zero(), U128::from_u64s_le(0, 1).wrapping_mul(U128::zero()));\n\n        // 1 * ( 1 << 64 ) == 1 << 64\n        assert_eq(U128::from_u64s_le(0, 1), U128::from_u64s_le(0, 1).wrapping_mul(U128::one()));\n\n        // ( 1 << 64 ) * 1 == 1 << 64\n        assert_eq(U128::from_u64s_le(0, 1), U128::one().wrapping_mul(U128::from_u64s_le(0, 1)));\n\n        // ( 1 << 64 ) * ( 1 << 64 ) == 1 << 64\n        assert_eq(U128::zero(), U128::from_u64s_le(0, 1).wrapping_mul(U128::from_u64s_le(0, 1)));\n        // -1 * -1 == 1\n        assert_eq(\n            U128::one(),\n            U128::from_u64s_le(0xffffffffffffffff, 0xffffffffffffffff).wrapping_mul(\n                U128::from_u64s_le(0xffffffffffffffff, 0xffffffffffffffff),\n            ),\n        );\n    }\n\n    #[test]\n    fn test_default() {\n        assert_eq(U128::default(), U128::zero());\n    }\n}\n","path":"std/uint128.nr"},"61":{"source":"use dep::ethereum::account_with_storage::{get_header, StorageWithinBlock};\nuse dep::ethereum::misc::types::{Address, Bytes32};\nuse dep::ethereum::account::{get_account, AccountWithinBlock, MAX_PREFIXED_KEY_NIBBLE_LEN};\nuse dep::ethereum::merkle_patricia_proofs::proof::{ProofInput, Key, Value, Proof, Node, Leaf, verify_merkle_proof};\nuse dep::ethereum::verifiers::storage::verify_storage_values;\nuse dep::ethereum::account_with_storage::get_account_with_storage;\nuse dep::hydra::bn254::{enc, dec};\nuse dep::keccak256::keccak256;\nuse dep::std::verify_proof;\n\n// bob sign nonce n & n-1\n// n-1 is hashed and check that keccak(sig(n-1))) exist in the storage of the contract\n// if it does, prove state of balanceCommit exist for that key(keccak(sig(n-1)))\n// use sig(n-1) to decrypt the balanceCommit of n-1 and save the value\n\n// updated Finalbalance = receipt_balance_change + n-1 decrypted balanceCommit\n// encrypt the FinalBalance with sign(n)\n\n// output chain_id, block_number, keccak(sign(n))[commit2], encrypted_FinalBalance\n\nfn main(\n    verification_key: [Field; 128],\n    proof: [Field; 456],\n    public_inputs: [Field; 8],\n    key_hash: Field,\n    bob_signature_nonce_1: [u8; 65],\n    bob_signature_nonce_2: [u8; 65],\n    chain_id: pub Field,\n    block_number: u64,\n    message_nonce_1: u64,\n    pub_x_1: [u8; 32],\n    pub_y_1: [u8; 32],\n    pub_x_2: [u8; 32],\n    pub_y_2: [u8; 32],\n    contract_address: Address\n) -> pub (Field, Field, Field, Field, Field, Field,  Field, Field) {\n\n\n    verify_proof(verification_key, proof, public_inputs, key_hash);\n\n    // ---- Check nonce are valid ------ //\n    let message_nonce_2 = message_nonce_1 + 1;\n    let hashed_message_1 = hash_u64(message_nonce_1);\n    let hashed_message_2 = hash_u64(message_nonce_2);\n    \n\n    // Create 64-byte signature by taking first 64 bytes\n    let mut sig_64_1: [u8; 64] = [0; 64];\n    let mut sig_64_2: [u8; 64] = [0; 64];\n    for i in 0..64 {\n        sig_64_1[i] = bob_signature_nonce_1[i];\n        sig_64_2[i] = bob_signature_nonce_2[i];\n    }\n\n    assert(std::ecdsa_secp256k1::verify_signature(pub_x_1, pub_y_1, sig_64_1, hashed_message_1));\n    assert(std::ecdsa_secp256k1::verify_signature(pub_x_2, pub_y_2, sig_64_2, hashed_message_2));\n\n    let balance_commit_slot = 2;\n\n    let commit_1_hash = \n        keccak256(hex_bytes_to_ascii(bob_signature_nonce_1), 132);\n    let commit_2_hash = \n        keccak256(hex_bytes_to_ascii(bob_signature_nonce_2), 132);\n    \n    //----- compute storage keys ----- //\n\n    let mut key_and_slot: [u8; 64] = [0; 64];    \n    for i in 0..32 {\n        key_and_slot[i] = commit_1_hash[i];\n    }\n    key_and_slot[63] = balance_commit_slot as u8;  \n    let commit_1_storage_key = keccak256(key_and_slot, 64);\n\n    for i in 0..32 {\n        key_and_slot[i] = commit_2_hash[i];\n    }\n    key_and_slot[63] = balance_commit_slot as u8;  \n    let balance_commit_1_storage_key = keccak256(key_and_slot, 64);\n\n    //---- Get Verified Storage Values ----- //\n        // get balance for key(commit_1_storage_key) => balance_commit_verified_storage.values[0]\n    let commit_1_verified_storage = unsafe {get_account_with_storage(\n        chain_id,\n        block_number,\n        contract_address,\n        commit_1_storage_key\n    )};\n    // If key value dosent exist in mapping (commit=>balance) then the oracle will reject\n    // therefore we might check mapping(commit=>bool) is true, but we can neglet it here\n    // as a false commitment wont match the sig, and a non mapped key will throw error\n\n   \n    \n    //------ Compose new balance -----------//\n    // @Dev: Security is low, for same sig and fiferent balance an attacker\n    // could figure out the length of the value, by checking the switching bytes\n    // But since we use 1 commit 1 derived key we get rid of this iussue\n    \n    // 1) decrypt balanceCommit for n-1 \n    let iv = [\n        message_nonce_1 as Field, \n        bytes_to_field(pub_x_1), \n        bytes_to_field(pub_y_1), \n        0\n    ];\n    let nonce_1_derived_key = derive_key_from_signature(bob_signature_nonce_1);\n    let encrypted_balance = safe_storage_to_field(commit_1_verified_storage.values[0]);\n    let decrypted_1_balance_commit_balance = \n        decrypt_balance(bob_signature_nonce_1, encrypted_balance);\n\n    // Assuming public_inputs[8] is the receipt_amount as a Field\n    let receipt_amount_field = public_inputs[1];\n\n  \n\n    // Adjust balance based on receipt_amount\n    let new_balance = (receipt_amount_field); // Subtract the positive value\n\n    // 3) encrypt the new balance with sign(n)\n    let new_key = derive_key_from_signature(bob_signature_nonce_2);\n    let balance_fields = [new_balance, 0, 0, 0, 0, 0, 0, 0];\n    let encrypted_fields = enc::encrypt(balance_fields, new_key, iv);\n\n    let encrypted_final_balance = encrypted_fields[0];\n    // nullifier serve to prevent double spending of same state, we dont need to check\n    // storage value for it, this pass to bob. If nullifier already exist bob's proof will be \n    // rejected in the smart contract\n    let block_hash_last_byte = commit_1_verified_storage.block_hash[31] as Field;\n    let commit_hash_last_byte = commit_2_hash[31] as Field;\n    let last_bytes = (block_hash_last_byte * 256) + commit_hash_last_byte;\n\n    // Combine last_bytes with public_inputs[9] by multiplying last_bytes by 2^16\n    // This achieves the same effect as a left shift but works with Field arithmetic\n    let combined_bytes = (last_bytes * 65536) + public_inputs[7];\n\n    // return chain_id, block_number, keccak(sign(n))[commit2], encrypted_FinalBalance\n    (\n        block_number as Field,\n        address_to_field(contract_address),\n        field_from_bytes_32_trunc(commit_1_verified_storage.block_hash),\n        encrypted_fields[0],\n        field_from_bytes_32_trunc(commit_2_hash),\n        public_inputs[5], // alice enc balance  \n        public_inputs[6], // alice commit \n        combined_bytes // 0x00..<commit, block><commit, block> slices \n    )\n}\n\n// Define a larger key size that can accommodate the nibble conversion of a 32-byte key\nglobal LARGER_KEY_SIZE: u32 = 132; // 2 * 32 + 68 (extra space for prefix)\n\n\n\nfn field_from_bytes_32_trunc(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..15 {\n        // covers bytes 16..30 (31 is truncated and ignored)\n        low = low + (bytes32[15 + 15 - i] as Field) * v;\n        v = v * 256;\n        // covers bytes 0..14\n        high = high + (bytes32[14 - i] as Field) * v;\n    }\n    // covers byte 15\n    low = low + (bytes32[15] as Field) * v;\n\n    low + high * v\n}\n\n\n// Derive a deterministic key from a signature\nfn derive_key_from_signature(signature: [u8; 65]) -> [Field; 4] {\n    let mut key = [0; 4];\n    for i in 0..4 {\n        let mut value: u64 = 0;\n        for j in 0..4 {\n            value = (value << 8) | (signature[i * 4 + j] as u64);\n        }\n        key[i] = value as Field;\n    }\n    key\n}\n\nfn decrypt_balance(\n    // Signature data\n    signature: [u8; 65],\n    \n    // Encrypted balance (field element)\n    encrypted_balance: Field,\n) -> pub Field {\n    // Derive key from signature (same as encryption)\n    let key = derive_key_from_signature(signature);\n    \n    // Create a fixed IV (same as encryption)\n    let iv = [0, 0, 0, 0];\n    \n    // Create encrypted fields array\n    let encrypted_fields = [encrypted_balance, 0, 0, 0, 0, 0, 0, 0];\n\n    \n    // Decrypt the fields\n    let decrypted_fields = dec::decrypt(encrypted_fields, key, iv);\n    \n    \n    // Return the first decrypted field element\n    decrypted_fields[0]\n}\n\n// Helper function to convert a single hex nibble to its ASCII character\nfn nibble_to_ascii(nibble: u8) -> u8 {\n    if nibble < 10 {\n        nibble + 48  // '0' to '9'\n    } else {\n        nibble + 87  // 'a' to 'f'\n    }\n}\n\n// Function to convert hex bytes to ASCII string representation\nfn hex_bytes_to_ascii(hex_bytes: [u8; 65]) -> [u8; 132] {\n    let mut result: [u8; 132] = [0; 132];\n    \n    // Add \"0x\" prefix\n    result[0] = 48;  // '0'\n    result[1] = 120; // 'x'\n    \n    // Convert each byte to two ASCII characters\n    for i in 0..65 {\n        let byte = hex_bytes[i];\n        let high_nibble = byte >> 4;\n        let low_nibble = byte & 0x0f;\n        \n        result[2 + i * 2] = nibble_to_ascii(high_nibble);\n        result[2 + i * 2 + 1] = nibble_to_ascii(low_nibble);\n    }\n    \n    result\n}\n\n// Function to convert bytes to a Field value\nfn bytes_to_field(bytes: [u8; 32]) -> Field {\n    let mut result: Field = 0;\n    \n    // Convert bytes to field\n    for i in 0..32 {\n        result = result * 256 + (bytes[i] as Field);\n    }\n    \n    result\n}\n\n// Function to safely convert storage value to field\nfn safe_storage_to_field(storage_value: [u8; 32]) -> Field {\n    // Convert bytes to field directly\n    // Noir's field type automatically handles overflow\n    bytes_to_field(storage_value)\n}\n\n// Unconstrained function to convert u64 to ASCII bytes\nunconstrained fn u64_to_ascii_bytes(value: u64) -> [u8; 20] {\n    let mut result: [u8; 20] = [0; 20];\n    let mut temp = value;\n    let mut pos = 19;\n    \n    // Handle zero case\n    if value == 0 {\n        result[19] = 48; // '0'\n    } else {\n        // Convert each digit to ASCII\n        while temp > 0 {\n            let digit = (temp % 10) as u8;\n            result[pos] = digit + 48; // Convert to ASCII\n            temp = temp / 10;\n            if pos > 0 {\n                pos -= 1;\n            }\n        }\n    }\n    \n    // Shift all digits to the right\n    let mut shifted: [u8; 20] = [0; 20];\n    let mut count = 0;\n    for i in 0..20 {\n        if result[i] != 0 {\n            count += 1;\n        }\n    }\n    \n    for i in 0..count {\n        shifted[20 - count + i] = result[20 - count + i];\n    }\n    \n    shifted\n}\n\n// Function to hash a u64 value using Keccak256\nfn hash_u64(value: u64) -> [u8; 32] {\n    // Convert value to ASCII bytes using unconstrained function\n    let digits = unsafe { u64_to_ascii_bytes(value) };\n    \n    // Count non-zero digits\n    let mut digit_count = 0;\n    for i in 0..20 {\n        if digits[i] != 0 {\n            digit_count += 1;\n        }\n    }\n    \n    // Copy digits to message\n    let mut message: [u8; 64] = [0; 64];\n    for i in 0..20 {\n        if i < digit_count {\n            message[i] = digits[20 - digit_count + i];\n        }\n    }\n    \n    // Hash the digits\n    keccak256(message, digit_count)\n}\n\n// Add these helper functions if not present\nfn address_to_field(address: Address) -> Field {\n    let mut result: Field = 0;\n    for i in 0..20 {\n        result = result * 256 + (address[i] as Field);\n    }\n    result\n}\n\n#[test]\nfn test_hash_u64_values() {\n    // Test with 1\n    let hash_1 = hash_u64(1);\n    let expected_hash_1: [u8; 32] = [\n        0xc8, 0x9e, 0xfd, 0xaa, 0x54, 0xc0, 0xf2, 0x0c, 0x7a, 0xdf, 0x61, 0x28, 0x82, 0xdf, 0x09, 0x50,\n        0xf5, 0xa9, 0x51, 0x63, 0x7e, 0x03, 0x07, 0xcd, 0xcb, 0x4c, 0x67, 0x2f, 0x29, 0x8b, 0x8b, 0xc6\n    ];\n    assert(hash_1 == expected_hash_1);\n    \n    // Test with 10\n    let hash_10 = hash_u64(10);\n    let expected_hash_10: [u8; 32] = [\n        0x1a, 0x19, 0x2f, 0xab, 0xce, 0x13, 0x98, 0x8b, 0x84, 0x99, 0x4d, 0x42, 0x96, 0xe6, 0xcd, 0xc4,\n        0x18, 0xd5, 0x5e, 0x2f, 0x1d, 0x7f, 0x94, 0x21, 0x88, 0xd4, 0x04, 0x0b, 0x94, 0xfc, 0x57, 0xac\n    ];\n    assert(hash_10 == expected_hash_10);\n    \n    // Test with 100\n    let hash_100 = hash_u64(100);\n    let expected_hash_100: [u8; 32] = [\n        0x8c, 0x18, 0x21, 0x0d, 0xf0, 0xd9, 0x51, 0x4f, 0x2d, 0x2e, 0x5d, 0x8c, 0xa7, 0xc1, 0x00, 0x97,\n        0x82, 0x19, 0xee, 0x80, 0xd3, 0x96, 0x8a, 0xd8, 0x50, 0xab, 0x5e, 0xad, 0x20, 0x82, 0x87, 0xb3\n    ];\n    assert(hash_100 == expected_hash_100);\n    \n    // Print the hashes for verification\n    println(\"Hash of 1:\");\n    println(hash_1);\n    println(\"Hash of 10:\");\n    println(hash_10);\n    println(\"Hash of 100:\");\n    println(hash_100);\n}\n\n\n#[test]\nfn test_init() {\n    // Chain ID for Sepolia testnet\n    let chain_id = 11155111;\n    \n    // Block number - using the value from our previous conversions\n    let block_number = 8275936;  // This is 0x7e4605\n    \n    // Message nonces\n    let message_nonce_1 = 1;\n    let message_nonce_2 = 2;\n    \n    // contract_address to check - using the correct type\n    let contract_address: Address = [0x58, 0x2B, 0xEE, 0x8f, 0x43, 0xBF, 0x20, 0x39, 0x64, 0xd3, 0x8c, 0x54, 0xFA, 0x03, 0xe6, 0x2d, 0x61, 0x61, 0x59, 0xfA];\n    \n    // Initialize verification key with zeros\n    let verification_key: [Field; 128] = [0; 128];\n    \n    // Initialize proof with zeros\n    let proof: [Field; 456] = [0; 456];\n    \n    // Initialize key hash with zero\n    let key_hash: Field = 0;\n    \n    // Public inputs - using direct hex values converted to Field\n    let public_inputs: [Field; 8] = [\n        0xaa36a7,\n        0x64,\n        0x7e47cc,\n        0x69e4b38e6c08bd6467a703a17cd77acb0badfa66,\n        0x6b94e5a8d9399817c935e4f76e2540baca94bc739afd85ee393833e95fc462,\n        0x211ba0c0b6ee0f11e6894da524fe8e9919f8d5faa6fd7e4a536d4e8e17004eef,\n        0x48fc0df33948d28957d5f62ee17643b0311d4dda43f2cf747839703c52f380,\n        0x64\n    ];\n\n    // Signatures (65 bytes) - keeping the same signatures as they're test values\n    let bob_signature_nonce_1: [u8; 65] = [\n        0x07, 0x2f, 0x3e, 0x1e, 0x23, 0xa2, 0x17, 0xbd, 0xc3, 0xc4, 0x1b, 0x4c, 0x61, 0x35, 0x2b, 0xcc,\n        0x78, 0xd8, 0x14, 0x0e, 0xb9, 0x81, 0x0b, 0xd3, 0xd3, 0x60, 0x37, 0xfb, 0x65, 0xc7, 0xaf, 0x40,\n        0x6d, 0x4c, 0x37, 0x72, 0xb0, 0xc4, 0xd4, 0xfb, 0x29, 0x8c, 0xec, 0x36, 0xd0, 0x9d, 0x64, 0x6f,\n        0xf6, 0xa2, 0x49, 0x71, 0x0e, 0x43, 0xcd, 0xf2, 0x85, 0x6e, 0x5d, 0x4e, 0xfd, 0xbf, 0x7b, 0xd3,\n        0x1c\n    ];\n    let bob_signature_nonce_2: [u8; 65] = [\n        0x47, 0x65, 0xf9, 0xcb, 0xeb, 0xb3, 0xff, 0x25, 0x24, 0x5f, 0xc8, 0xe3, 0x81, 0x8f, 0x36, 0xa2,\n        0xf4, 0xfa, 0x09, 0xf9, 0x89, 0xd3, 0x20, 0xcd, 0xef, 0xc4, 0x65, 0xb2, 0x95, 0xd6, 0xa0, 0xaf,\n        0x37, 0x73, 0x11, 0x57, 0x5a, 0xc4, 0x51, 0x99, 0xd9, 0xab, 0x0a, 0x9f, 0x58, 0x54, 0x3f, 0x12,\n        0xf2, 0x5e, 0x33, 0xdc, 0xc4, 0xc7, 0xe7, 0xf0, 0x93, 0x19, 0x88, 0x68, 0x20, 0x88, 0xb6, 0xe7,\n        0x1c\n    ];\n\n    // Public key coordinates - keeping the same public keys as they're test values\n    let pub_x_1: [u8; 32] = [\n        0xca, 0xb1, 0x4a, 0x0b, 0xb5, 0x57, 0xdf, 0xe9, 0x0a, 0x26, 0x8d, 0xcd, 0x04, 0xf1, 0x7e, 0x2e,\n        0xa8, 0xd8, 0xcc, 0xd5, 0x57, 0x71, 0xaa, 0x18, 0xec, 0x72, 0x3a, 0xf2, 0xee, 0x45, 0x92, 0xe6\n    ];\n    let pub_y_1: [u8; 32] = [\n        0x75, 0xd4, 0x4b, 0xb8, 0xbc, 0x98, 0xdb, 0x93, 0x24, 0x0f, 0x48, 0x07, 0x7c, 0x63, 0xaa, 0x4b,\n        0x29, 0xd5, 0x9a, 0xa3, 0x35, 0xcf, 0xf4, 0xb2, 0xa0, 0x88, 0x23, 0x4f, 0x69, 0xc2, 0x2e, 0xba\n    ];\n\n    let pub_x_2: [u8; 32] = [\n        0x97, 0x0f, 0xaa, 0x1e, 0xf6, 0xfd, 0xfe, 0xdc, 0xc5, 0x21, 0x56, 0xe4, 0x88, 0x0d, 0x2a, 0x0d,\n        0xce, 0x57, 0xaf, 0xfa, 0xf1, 0x99, 0xe6, 0x60, 0x8e, 0x9b, 0x23, 0xc9, 0xf0, 0x85, 0xd2, 0xd1\n    ];\n    let pub_y_2: [u8; 32] = [\n        0x34, 0x2a, 0x1e, 0xa1, 0xd1, 0x84, 0x38, 0x92, 0x34, 0x7a, 0x8f, 0x9a, 0x0d, 0xcb, 0x09, 0x72,\n        0xfc, 0xd0, 0x3f, 0xe0, 0x17, 0xd2, 0x6c, 0xb2, 0xb4, 0xcd, 0xd4, 0x63, 0xbf, 0x7b, 0x9a, 0xf2\n    ];\n    \n    let (block_number_field, contract_address_field, block_hash_field, encrypted_balance_field, commit_2_hash_field, alice_enc_balance_field, alice_commit_hash_field, combined_bytes_field) = main(\n        verification_key,\n        proof,\n        public_inputs,\n        key_hash,\n        bob_signature_nonce_1, \n        bob_signature_nonce_2, \n        chain_id, \n        block_number,\n        message_nonce_1,\n        pub_x_1,\n        pub_y_1,\n        pub_x_2,\n        pub_y_2,\n        contract_address\n    );\n    \n    println(\"---- CIRCUIT OUTPUT ----\");\n    println(\"block_number\");\n    println(block_number_field);\n    println(\"contract_address\");\n    println(contract_address_field);\n    println(\"block_hash\");\n    println(block_hash_field);\n    println(\"encrypted_balance\");\n    println(encrypted_balance_field);\n    println(\"commit_2_hash\");\n    println(commit_2_hash_field);\n\n    println(\"alice enc balance\");\n    println(alice_enc_balance_field);\n    println(\"alice commit hash\");\n    println(alice_commit_hash_field);\n    println(\"alice utility bytes\");\n    println(combined_bytes_field);\n  \n    println(\"---- END OF CIRCUIT OUTPUT ----\");\n}\n","path":"/home/drone/projects/rione/circuits/main/gazometer_p2p/bob_recursive/src/main.nr"},"63":{"source":"use crate::account::{MAX_ACCOUNT_DEPTH_NO_LEAF_M, MAX_ACCOUNT_LEAF_LEN, MAX_ACCOUNT_STATE_LEN};\nuse crate::header::{BlockHeaderPartial, get_header};\nuse crate::merkle_patricia_proofs::proof::ProofInput;\nuse crate::misc::{\n    bytes::right_pad,\n    fragment::Fragment,\n    types::{Address, Bytes32, BYTES32_LENGTH, HASH_LEN},\n};\nuse crate::rlp::decode::decode_string;\nuse crate::serde::Serde;\nuse crate::verifiers::account::verify_account;\nuse crate::verifiers::storage::{verify_storage_values, verify_storage_values_against_block};\n\nuse dep::std::hash::keccak256;\n\nglobal MAX_KEY_LEN: u32 = 32;\nglobal MAX_PREFIXED_KEY_NIBBLE_LEN: u32 = 66; // (MAX_KEY_LEN + 1) * 2\nglobal MAX_STORAGE_DEPTH_NO_LEAF_M: u32 = 6; // Emperically correct values to be determined after we scan ethereum state trie.\n\nglobal MAX_STORAGE_VALUE_LEN: u32 = 32; // Values taken from storageProofConfig in storage.ts.\nglobal MAX_STORAGE_LEAF_LEN: u32 = 69;\n\npub struct Account {\n    pub nonce: u64,\n    pub balance: Field,\n    pub storage_root: Bytes32,\n    pub code_hash: Bytes32,\n}\n\nimpl Eq for Account {\n    fn eq(self, other: Self) -> bool {\n        (self.nonce == other.nonce)\n            & (self.balance == other.balance)\n            & (self.storage_root == other.storage_root)\n            & (self.code_hash == other.code_hash)\n    }\n}\n\n// For now oracle does not support returning array of arrays so at the moment we support only one storage proof.\n// When https://github.com/noir-lang/noir/issues/4498 is resolved we can change to `StateAndStorageProof<N>` and `storage_proof: [StorageProof; N]`.\nstruct StateAndStorageProofInput {\n    account: Account,\n    state_proof_input: ProofInput<MAX_PREFIXED_KEY_NIBBLE_LEN, MAX_ACCOUNT_STATE_LEN, MAX_ACCOUNT_DEPTH_NO_LEAF_M, MAX_ACCOUNT_LEAF_LEN>,\n    storage_proof_input: ProofInput<MAX_PREFIXED_KEY_NIBBLE_LEN, MAX_STORAGE_VALUE_LEN, MAX_STORAGE_DEPTH_NO_LEAF_M, MAX_STORAGE_LEAF_LEN>,\n}\n\npub struct StorageWithinBlock<let N: u32> {\n    pub block_hash: Bytes32,\n    pub account: Account,\n    pub values: [Bytes32; N],\n}\n\ntype ProofInputSerialized<let LEN: u32> = [Field; LEN];\n\nimpl Eq for StorageWithinBlock<1> {\n    fn eq(self, other: Self) -> bool {\n        (self.block_hash == other.block_hash)\n            & (self.account == other.account)\n            & (self.values[0] == other.values[0])\n    }\n}\n\nfn assert_storage_key_equals(\n    storage_key: Bytes32,\n    storage_key_hash: [u8; MAX_PREFIXED_KEY_NIBBLE_LEN],\n) {\n    let storage_key_hash_fragment = Fragment::new(\n        MAX_PREFIXED_KEY_NIBBLE_LEN - HASH_LEN,\n        HASH_LEN,\n        storage_key_hash,\n    );\n    let other_storage_key_hash_fragment =\n        Fragment::from_array(keccak256(storage_key, BYTES32_LENGTH as u32));\n    assert(\n        storage_key_hash_fragment.eq(other_storage_key_hash_fragment),\n        \"Storage key does not match the argument\",\n    );\n}\n\nfn get_fragment<let N: u32>(left_padded_value: [u8; N]) -> Fragment<N, u8> {\n    let value_len = right_pad(left_padded_value).len();\n    let value_offset = N - value_len;\n    Fragment::new(value_offset, value_len, left_padded_value)\n}\n\nfn get_storage_value(\n    rlp_encoded_value: [u8; MAX_STORAGE_VALUE_LEN],\n) -> [u8; MAX_STORAGE_VALUE_LEN] {\n    let mut storage_value = get_fragment(rlp_encoded_value);\n    let rlp_fragment = decode_string(storage_value);\n    let rlp_header_len = rlp_fragment.offset;\n\n    // Storage value is maximum 32 bytes long, so its RLP-encoding's header is maximum 1 byte long.\n    assert(rlp_header_len <= 1, \"Expected RLP header to be maximum 1 byte long\");\n    if rlp_fragment.offset == 1 {\n        let rlp_header_position = storage_value.offset;\n        storage_value.data[rlp_header_position] = 0;\n    }\n\n    storage_value.data\n}\n\nunconstrained pub fn get_account_with_storage(\n    chain_id: Field,\n    block_number: u64,\n    address: Address,\n    storage_key: Bytes32,\n) -> StorageWithinBlock<1> {\n    let BlockHeaderPartial { number, hash, state_root, transactions_root: _, receipts_root: _ } =\n        unsafe { get_header(chain_id, block_number) };\n    \n    // Explicitly verify that the header is for the requested block number\n    assert(number == block_number, \"Header block number does not match requested block number\");\n    let StateAndStorageProofInput { account, state_proof_input, storage_proof_input } =\n        unsafe { get_proof_unconstrained(chain_id, block_number, address, storage_key) };\n    \n    verify_account(address, account, state_proof_input, state_root);\n\n    // Use the more robust verification against block\n \n    verify_storage_values_against_block(\n        chain_id,\n        block_number,\n        [storage_proof_input],\n        account.storage_root\n    );\n    \n    //assert_storage_key_equals(storage_key, storage_proof_input.key);\n  \n    StorageWithinBlock {\n        block_hash: hash,\n        account,\n        values: [get_storage_value(storage_proof_input.value)],\n    }\n}\n\npub fn verify_storage_proof_at_block_number(\n    chain_id: Field,\n    block_number: u64,\n    address: Address,\n    storage_key: Bytes32,\n    expected_value: Bytes32\n) -> bool {\n    // Get the block header to verify block number\n    let BlockHeaderPartial { number, hash, state_root, transactions_root: _, receipts_root: _ } =\n        unsafe { get_header(chain_id, block_number) };\n    \n    // Explicitly verify that the header is for the requested block number\n    assert(number == block_number, \"Header block number does not match requested block number\");\n \n    // Get the proof data from the oracle\n    let StateAndStorageProofInput { account, state_proof_input, storage_proof_input } =\n        unsafe { get_proof_unconstrained(chain_id, block_number, address, storage_key) };\n    \n    // Verify the account against the state root from the block header\n    verify_account(address, account, state_proof_input, state_root);\n    // Verify the storage proof against the account's storage root\n    verify_storage_values_against_block(\n        chain_id,\n        block_number,\n        [storage_proof_input],\n        account.storage_root\n    );\n\n    // Verify the storage key matches what was requested\n    assert_storage_key_equals(storage_key, storage_proof_input.key);\n    \n    // Decode the RLP-encoded value from the proof\n    let actual_value = get_storage_value(storage_proof_input.value);\n    \n    // Check if the value matches the expected value\n    actual_value == expected_value\n}\n\n#[oracle(get_proof)]\nunconstrained fn get_proof_oracle<let STATE_PROOF_INPUT_LEN: u32, let STORAGE_PROOF_INPUT: u32>(\n    _chain_id: Field,\n    _block_no: u64,\n    _address: Address,\n    _storage_key: Bytes32,\n    ) -> (Account, ProofInputSerialized<STATE_PROOF_INPUT_LEN>, ProofInputSerialized<STORAGE_PROOF_INPUT>) {}\n\nunconstrained fn get_proof_unconstrained(\n    chain_id: Field,\n    block_no: u64,\n    address: Address,\n    storage_key: Bytes32,\n) -> StateAndStorageProofInput {\n    let (account, state_proof_input, storage_proof_input) =\n        unsafe { get_proof_oracle(chain_id, block_no, address, storage_key) };\n    \n    let state_proof_input = unsafe { Serde::deserialize(state_proof_input) };\n    \n    let storage_proof_input = unsafe { Serde::deserialize(storage_proof_input) };\n    StateAndStorageProofInput { account, state_proof_input, storage_proof_input }\n}","path":"/home/drone/projects/rione/circuits/ethereum/circuits/lib/src/account_with_storage.nr"},"69":{"source":"use crate::misc::types::Bytes32;\nuse crate::verifiers::header::verify_header;\nuse crate::misc::{fragment::Fragment, types::{BYTES32_LENGTH, ADDRESS_LENGTH, Address}};\nuse crate::uint256::U256;\nuse crate::merkle_patricia_proofs::proof::{ProofInput, Proof, Node, Leaf, MAX_NODE_LEN};\nuse crate::rlp::types::RlpFragment;\nuse dep::std::mem::zeroed;\n\nglobal MAX_HEADER_RLP_LEN: u32 = 708;\n\npub struct BlockHeaderPartial {\n    pub number: u64,\n    pub hash: Bytes32,\n    pub state_root: Bytes32,\n    pub transactions_root: Bytes32,\n    pub receipts_root: Bytes32,\n}\n\npub type BlockHeaderRlp = BoundedVec<u8, MAX_HEADER_RLP_LEN>;\n\npub fn get_header(chain_id: Field, block_number: u64) -> BlockHeaderPartial {\n    let (block_header_partial, block_header_rlp) = unsafe { get_header_unconstrained(chain_id, block_number) };\n    verify_header(chain_id, block_header_partial, block_header_rlp);\n    assert(block_header_partial.number == block_number, \"Block number does not match the argument\");\n    block_header_partial\n}\n\n#[oracle(get_header)]\nunconstrained fn get_header_oracle(_chain_id: Field, _block_no: u64) -> (BlockHeaderPartial, BlockHeaderRlp) {}\n\nunconstrained fn get_header_unconstrained(chain_id: Field, block_no: u64) -> (BlockHeaderPartial, BlockHeaderRlp) {\n    unsafe { get_header_oracle(chain_id, block_no) }\n}\n\nfn alter_array(bytes: [Field; 32]) -> [u8; 32] {\n    let mut result: [u8; 32] = zeroed();\n    for i in 0..32 {\n        result[i] = bytes[i] as u8;\n    }\n    result\n}\n","path":"/home/drone/projects/rione/circuits/ethereum/circuits/lib/src/header.nr"},"72":{"source":"use crate::rlp::types::RlpList;\nuse crate::rlp::decode::{decode_to_rlp_header, decode_list_of_small_strings, decode_list};\nuse crate::misc::{\n    fragment::Fragment, arrays::{sub_array_equals_up_to_length, memcpy_up_to_length},\n    types::{Hash, HASH_LEN}, bytes::{bytes_to_nibbles, byte_to_nibbles, right_pad}\n};\nuse dep::std::hash::keccak256;\n\nglobal MAX_NODE_LEN: u32 = 532;\nglobal MAX_NODE_FIELDS: u32 = 17;\nglobal BRANCH_NODE_NUM_FIELDS: u32 = 17;\nglobal EXTENSION_NODE_NUM_FIELDS: u32 = 2;\nglobal EVEN: u32 = 0;\nglobal ODD: u32 = 1;\n\npub type Node = [u8; MAX_NODE_LEN];\npub type Leaf<let MAX_LEAF_LEN: u32> = [u8; MAX_LEAF_LEN];\npub type Key<let MAX_PREFIXED_KEY_NIBBLE_LEN: u32> = [u8; MAX_PREFIXED_KEY_NIBBLE_LEN];\npub type Value<let MAX_VALUE_LEN: u32> = [u8; MAX_VALUE_LEN];\n\npub struct Proof<let MAX_DEPTH_NO_LEAF: u32, let MAX_LEAF_LEN: u32> {\n\tpub nodes: [Node; MAX_DEPTH_NO_LEAF],\n    // Leaf has a different max length than internal node as it contains the value of arbitrary length.\n\tpub leaf: Leaf<MAX_LEAF_LEN>,\n\tpub depth: u64\n}\n\npub struct ProofInput<let MAX_PREFIXED_KEY_NIBBLE_LEN: u32, let MAX_VALUE_LEN: u32, let MAX_DEPTH_NO_LEAF: u32, let MAX_LEAF_LEN: u32> {\n    pub key: Key<MAX_PREFIXED_KEY_NIBBLE_LEN>,\n    pub value: Value<MAX_VALUE_LEN>,\n    pub proof: Proof<MAX_DEPTH_NO_LEAF, MAX_LEAF_LEN>\n}\n\nimpl<let MAX_DEPTH_NO_LEAF: u32, let MAX_LEAF_LEN: u32> Eq for Proof<MAX_DEPTH_NO_LEAF, MAX_LEAF_LEN> {\n    fn eq(self, other: Self) -> bool {\n        (self.depth == other.depth) & (self.nodes == other.nodes) & (self.leaf == other.leaf)\n    }\n}\n\nimpl<let MAX_PREFIXED_KEY_NIBBLE_LEN: u32, let MAX_VALUE_LEN: u32, let MAX_DEPTH_NO_LEAF: u32, let MAX_LEAF_LEN: u32> Eq for ProofInput<MAX_PREFIXED_KEY_NIBBLE_LEN, MAX_VALUE_LEN, MAX_DEPTH_NO_LEAF, MAX_LEAF_LEN> {\n    fn eq(self, other: Self) -> bool {\n        (self.key == other.key) & (self.value == other.value) & (self.proof == other.proof)\n    }\n}\n\npub fn get_node_len<let MAX_LEN: u32>(node: [u8; MAX_LEN]) -> u32 {\n    let node_rlp_header = decode_to_rlp_header(Fragment::from_array(node));\n    let node_unpadded_len = node_rlp_header.offset + node_rlp_header.length;\n    assert(node_unpadded_len <= MAX_LEN, \"Node RLP length exceeds MAX_LEN\");\n\n    node_unpadded_len\n}\n\n// Prefixes mean:\n// 0 - Extension node, even number of nibbles\n// 1 - Extension node, odd number of nibbles\n// 2 - Leaf node, even number of nibbles\n// 3 - Leaf node, odd number of nibbles\npub fn parity(prefix: u8) -> u32 {\n    assert(prefix < 4, \"Prefix must be 0, 1, 2 or 3\");\n    (prefix % 2) as u32\n}\n\n// Leaf and extension nodes are RLP lists with 2 elements: prefixed key nibbles (in bytes) and value.\n// This function removes the prefix and returns appropriate number of key nibbles according to the parity of the prefix (see function: parity).\npub fn strip_prefix<let MAX_PREFIXED_KEY_NIBBLE_LEN: u32>(prefixed_key_bytes: Fragment<MAX_PREFIXED_KEY_NIBBLE_LEN, u8>) -> Fragment<MAX_PREFIXED_KEY_NIBBLE_LEN, u8> {\n    let mut prefixed_key_nibbles = bytes_to_nibbles(prefixed_key_bytes);\n\n    let prefix = prefixed_key_nibbles.pop_front();\n    let parity = parity(prefix);\n    if (parity == EVEN) {\n        assert(prefixed_key_nibbles.pop_front() == 0, \"Expected a zero after a prefix of even parity\");\n    }\n\n    prefixed_key_nibbles\n}\n\npub fn extract_hash_from_branch_node<let MAX_PREFIXED_KEY_NIBBLE_LEN: u32>(\n    node: Node,\n    node_rlp_list: RlpList<MAX_NODE_FIELDS>,\n    key_nibbles: Fragment<MAX_PREFIXED_KEY_NIBBLE_LEN, u8>,\n    key_ptr: &mut u32\n) -> Fragment<HASH_LEN, u8> {\n    let curr_nibble = key_nibbles.at(*key_ptr) as u32;\n    assert(\n        node_rlp_list.get(curr_nibble).length == HASH_LEN, \"Expected a hash at position given by the key nibble\"\n    );\n    *key_ptr += 1;\n\n    Fragment::new(node_rlp_list.get(curr_nibble).offset, HASH_LEN, node).focus()\n}\n\npub fn extract_hash_from_extension_node<let MAX_PREFIXED_KEY_NIBBLE_LEN: u32>(\n    node: Node,\n    node_rlp_list: RlpList<MAX_NODE_FIELDS>,\n    key_nibbles: Fragment<MAX_PREFIXED_KEY_NIBBLE_LEN, u8>,\n    key_ptr: &mut u32\n) -> Fragment<HASH_LEN, u8> {\n    let prefixed_extension_key_part: Fragment<MAX_PREFIXED_KEY_NIBBLE_LEN, u8> = Fragment::new(node_rlp_list.get(0).offset, node_rlp_list.get(0).length, node).focus();\n\n    let (prefix, _) = byte_to_nibbles(prefixed_extension_key_part.at(0));\n    assert((prefix == 0) | (prefix == 1), \"Extension parity prefix must be 0 or 1\");\n    let extension_key_part = strip_prefix(prefixed_extension_key_part); // Extension nodes have a prefix that needs to be removed.\n    let curr_key_nibbles_part = key_nibbles.subfragment(*key_ptr, extension_key_part.length);\n    assert(\n        extension_key_part == curr_key_nibbles_part, \"Extension key part does not correspond to given key nibbles\"\n    );\n    assert(node_rlp_list.get(1).length == HASH_LEN, \"Expected a hash at the end of the extension node\");\n    *key_ptr += extension_key_part.length;\n\n    Fragment::new(node_rlp_list.get(1).offset, HASH_LEN, node).focus()\n}\n\npub fn extract_hash<let MAX_PREFIXED_KEY_NIBBLE_LEN: u32>(\n    node: Node,\n    key_nibbles: Fragment<MAX_PREFIXED_KEY_NIBBLE_LEN, u8>,\n    key_ptr: &mut u32\n) -> Fragment<HASH_LEN, u8> {\n    let mut hash = Fragment::from_array([0; HASH_LEN]);\n    let node_rlp_list: RlpList<MAX_NODE_FIELDS> = decode_list_of_small_strings(Fragment::from_array(node));\n\n    if (node_rlp_list.len == BRANCH_NODE_NUM_FIELDS) {\n        hash = extract_hash_from_branch_node(node, node_rlp_list, key_nibbles, key_ptr);\n    } else if (node_rlp_list.len == EXTENSION_NODE_NUM_FIELDS) {\n        hash = extract_hash_from_extension_node(node, node_rlp_list, key_nibbles, key_ptr);\n    } else {\n        assert(false, \"Invalid node type\");\n    }\n\n    hash\n}\n\npub fn verify_node_hash<let MAX_LEN: u32>(node: [u8; MAX_LEN], hash: [u8; HASH_LEN]) {\n    assert(keccak256(node, get_node_len(node) as u32) == hash, \"Invalid node hash\");\n}\n\npub fn verify_leaf<let MAX_LEAF_LEN: u32, let MAX_PREFIXED_KEY_NIBBLE_LEN: u32, let MAX_VALUE_LEN: u32>(\n    leaf: Leaf<MAX_LEAF_LEN>,\n    key_nibbles: Fragment<MAX_PREFIXED_KEY_NIBBLE_LEN, u8>,\n    key_ptr: &mut u32,\n    value: Value<MAX_VALUE_LEN>\n) {\n    let leaf_rlp_list: RlpList<2> = decode_list(Fragment::from_array(leaf));\n    assert(leaf_rlp_list.len == 2, \"Leaf expected to have 2 fields\");\n\n    let prefixed_leaf_key_part: Fragment<MAX_PREFIXED_KEY_NIBBLE_LEN, u8> = Fragment::new(leaf_rlp_list.get(0).offset, leaf_rlp_list.get(0).length, leaf).focus();\n\n    let (prefix, _) = byte_to_nibbles(prefixed_leaf_key_part.at(0));\n    assert((prefix == 2) | (prefix == 3), \"Leaf parity prefix must be 2 or 3\");\n    let leaf_key_part = strip_prefix(prefixed_leaf_key_part);\n    let left_key_ending = key_nibbles.subfragment(*key_ptr, leaf_key_part.length);\n    assert(leaf_key_part == left_key_ending, \"Key mismatch in the leaf\");\n    *key_ptr += leaf_key_part.length;\n    assert(*key_ptr == key_nibbles.length, \"Expected to consume all key nibbles\");\n\n    let value = right_pad(value);\n    let value_rlp_fragment = leaf_rlp_list.get(1);\n    // Verify that extracted value matches the expected value.\n    assert(value_rlp_fragment.length == value.len, \"Value length mismatch\");\n    assert(\n        sub_array_equals_up_to_length(\n            value.storage,\n            leaf,\n            value_rlp_fragment.offset,\n            value_rlp_fragment.length\n        ), \"Value mismatch\"\n    );\n}\n\npub fn verify_merkle_proof<let MAX_PREFIXED_KEY_NIBBLE_LEN: u32, let MAX_VALUE_LEN: u32, let MAX_DEPTH: u32, let MAX_LEAF_LEN: u32>(\n    key: Key<MAX_PREFIXED_KEY_NIBBLE_LEN>,\n    value: Value<MAX_VALUE_LEN>,\n    root: Hash,\n    proof: Proof<MAX_DEPTH, MAX_LEAF_LEN>\n) {\n    let key = right_pad(key);\n    let key_nibbles = bytes_to_nibbles(Fragment::from_vec(key));\n    let mut key_ptr = 0;\n\n    // Verify hashes of all the nodes in the proof path.\n    let mut curr_hash = Fragment::from_array(root);\n    for i in 0..MAX_DEPTH {    \n        // Handle the case where proof.depth is 0 by using a conditional\n        // that avoids subtraction when depth is 0\n        let should_process = (proof.depth > 0) & (i as u64 + 1 < proof.depth);\n        if should_process {\n            verify_node_hash(proof.nodes[i], curr_hash.data);\n            curr_hash = extract_hash(proof.nodes[i], key_nibbles, &mut key_ptr);\n        }\n    }\n    \n    // Only verify the leaf if proof.depth is greater than 0\n    if proof.depth > 0 {\n        verify_node_hash(proof.leaf, curr_hash.data);\n        verify_leaf(proof.leaf, key_nibbles, &mut key_ptr, value);\n    }\n}\n","path":"/home/drone/projects/rione/circuits/ethereum/circuits/lib/src/merkle_patricia_proofs/proof.nr"},"74":{"source":"use dep::std::{mem::zeroed, wrapping_add};\nuse crate::misc::fragment::Fragment;\n\npub fn alter_array<let ARRAY_LEN: u32>(array: [u8; ARRAY_LEN]) -> [u8; ARRAY_LEN] {\n    let mut copy = array.map(|x| x);\n    copy[0] = wrapping_add(copy[0], 1);\n    copy\n}\n\npub fn alter_fragment<let MAX_LEN: u32>(fragment: Fragment<MAX_LEN, u8>) -> Fragment<MAX_LEN, u8> {\n    let mut copy = fragment;\n    copy.set(0, wrapping_add(copy.at(0), 1));\n    copy\n}\n\npub fn field_to_u8_array<let ARRAY_LEN: u32>(array: [Field; ARRAY_LEN]) -> [u8; ARRAY_LEN] {\n    let mut result: [u8; ARRAY_LEN] = zeroed();\n    for i in 0..ARRAY_LEN {\n        result[i] = array[i] as u8;\n    }\n    result\n}\n\npub fn u8_to_field_array<let ARRAY_LEN: u32>(array: [u8; ARRAY_LEN]) -> [Field; ARRAY_LEN] {\n    let mut result: [Field; ARRAY_LEN] = zeroed();\n    for i in 0..ARRAY_LEN {\n        result[i] = array[i] as Field;\n    }\n    result\n}\n\npub fn resize<TItem, let NEW_LEN: u32, let OLD_LEN: u32>(src: [TItem; OLD_LEN]) -> [TItem; NEW_LEN] {\n    assert(NEW_LEN >= OLD_LEN, \"New length must be greater than or equal to old length\");\n    let mut dest = [zeroed(); NEW_LEN];\n    for i in 0..OLD_LEN {\n        dest[i] = src[i];\n    }\n    dest\n}\n\npub(crate) fn memcpy_up_to_length<TItem, let SRC_LEN: u32, let DEST_LEN: u32>(dest: &mut [TItem; DEST_LEN], src: [TItem; SRC_LEN], offset: u32, length: u32) {\n    assert(length <= DEST_LEN, \"Destination index out of bound\");\n    assert(offset + length <= SRC_LEN, \"Source index out of bound\");\n    for i in 0..DEST_LEN {\n        if i < length {\n            (*dest)[i] = src[offset + i];\n        }\n    }\n}\n\n// Fills destination array with content of source array starting from the offset in source array.\npub(crate) fn memcpy<TItem, let SRC_LEN: u32, let DEST_LEN: u32>(dest: &mut [TItem; DEST_LEN], src: [TItem; SRC_LEN], offset: u32) {\n    memcpy_up_to_length(dest, src, offset, DEST_LEN);\n}\n\npub fn subarray_inferred_len<TItem, let SRC_LEN: u32, let DEST_LEN: u32>(src: [TItem; SRC_LEN], offset: u32) -> [TItem; DEST_LEN] {\n    let mut dest = [zeroed(); DEST_LEN];\n    memcpy(&mut dest, src, offset);\n    dest\n}\n\npub fn sub_array_equals_up_to_length<TItem, let SUBARRAY_LEN: u32, let ARRAY_LEN: u32>(\n    subarray: [TItem; SUBARRAY_LEN],\n    array: [TItem; ARRAY_LEN],\n    offset: u32,\n    length: u32\n) -> bool where TItem: Eq {\n    assert(length <= SUBARRAY_LEN, \"Subarray index out of bound\");\n    assert(offset + length <= ARRAY_LEN, \"Array index out of bound\");\n    let mut result = true;\n    for i in 0..SUBARRAY_LEN {\n        if i < length {\n            result &= subarray[i] == array[offset + i];\n        }\n    }\n    result\n}\n\npub fn sub_array_equals<TItem, let SUBARRAY_LEN: u32, let ARRAY_LEN: u32>(\n    subarray: [TItem; SUBARRAY_LEN],\n    array: [TItem; ARRAY_LEN],\n    offset: u32\n) -> bool where TItem: Eq {\n    assert(offset + SUBARRAY_LEN <= ARRAY_LEN, \"Array index out of bound\");\n    let mut result = true;\n    for i in 0..SUBARRAY_LEN {\n        result &= subarray[i] == array[offset + i];\n    }\n    result\n}\n","path":"/home/drone/projects/rione/circuits/ethereum/circuits/lib/src/misc/arrays.nr"},"78":{"source":"use crate::misc::fragment::Fragment;\n\npub fn byte_to_nibbles(byte: u8) -> (u8, u8) {\n    let upper = byte / 16;\n    let lower = byte - 16 * upper;\n\n    (upper, lower)\n}\n\npub fn bytes_to_nibbles<let MAX_NIBBLE_LEN: u32>(bytes: Fragment<MAX_NIBBLE_LEN, u8>) -> Fragment<MAX_NIBBLE_LEN, u8> {\n    assert(\n        MAX_NIBBLE_LEN >= 2 * bytes.length, \"Bytes implicit data length must be at least 2 times larger than bytes explicit length\"\n    );\n\n    let nibbles = &mut Fragment::new_with_length(2 * bytes.length, [0; MAX_NIBBLE_LEN]);\n    bytes.each(\n        |byte, i| {\n        let (hi, lo) = byte_to_nibbles(byte);\n\n        nibbles.set(2 * i, hi);\n        nibbles.set(2 * i + 1, lo);\n    }\n    );\n\n    *nibbles\n}\n\npub fn nibbles_to_byte(upper: u8, lower: u8) -> u8 {\n    assert(upper < 16, \"Nibble value must be less than 16\");\n    assert(lower < 16, \"Nibble value must be less than 16\");\n\n    upper * 16 + lower\n}\n\npub fn nibbles_to_bytes<let BYTES_LEN: u32, let NIB_LEN: u32>(nibbles: [u8; NIB_LEN]) -> [u8; BYTES_LEN] {\n    assert(NIB_LEN == 2 * BYTES_LEN, \"Generic arguments don't match\");\n\n    let mut bytes = [0; BYTES_LEN];\n\n    for i in 0..NIB_LEN / 2 {\n        let byte = nibbles_to_byte(nibbles[2 * i], nibbles[2 * i + 1]);\n        bytes[i] = byte;\n    }\n\n    bytes\n}\n\npub fn right_pad<let N: u32>(arr: [u8; N]) -> BoundedVec<u8, N> {\n    byte_value(arr)\n}\n\npub fn left_to_right_padding<let N: u32>(nibbles: [u8; N]) -> ([u8; N], u32) {\n    let mut BoundedVec {storage: shifted, len} = right_pad(nibbles);\n    if (len % 2 == 1) {\n        shift_right_by_one(&mut shifted);\n        len += 1;\n    }\n\n    let shifted_by = N - len;\n    (shifted, shifted_by)\n}\n\npub fn shift_right_by_one<let N: u32>(arr: &mut [u8; N]) {\n    assert(arr[N - 1] == 0, \"Last element must be zero to shift the array right by one\");\n\n    let mut last = 0;\n    for i in 0..N {\n        let tmp = (*arr)[i];\n        (*arr)[i] = last;\n        last = tmp;\n    }\n}\n\npub(crate) fn left_byte_shift<let N: u32>(input: [u8; N], n: u32) -> [u8; N] {\n    let mut out = [0; N];\n\n    for i in 0..N {\n        let index_ind = (((i + n) as u32) < (N as u32)) as u32;\n        out[i] = (index_ind as u8) * input[index_ind * (i + n)];\n    }\n\n    out\n}\n\n// Converts big-endian byte array to a right-padded one.\npub(crate) fn byte_value<let N: u32>(in_value: [u8; N]) -> BoundedVec<u8, N> {\n    let mut value_length = 0;\n\n    for i in 0..N {\n        let num_bytes_ind = (value_length == 0) as u32;\n        let byte_ind = (in_value[i] != 0) as u32;\n        value_length = num_bytes_ind * byte_ind * (N - i) + (1 - num_bytes_ind) * value_length;\n    }\n\n    let value = left_byte_shift(in_value, N - value_length);\n\n    BoundedVec { storage: value, len: value_length }\n}\n\npub fn add_bigint<let N: u32>(left: [u8; N], right: [u8; N]) -> [u8; N] {\n    let mut carry: u32 = 0;\n    let mut result: [u8; N] = [0; N];\n\n    for j in 0..N {\n        let index = N - j - 1;\n        let sum = left[index] as u32 + right[index] as u32 + carry;\n        result[index] = sum as u8;\n        carry = sum >> 8;\n    }\n\n    assert(carry == 0, \"Addition overflow\");\n\n    result\n}\n","path":"/home/drone/projects/rione/circuits/ethereum/circuits/lib/src/misc/bytes.nr"},"82":{"source":"use crate::misc::{arrays::{memcpy_up_to_length, resize}, iterator::Iterator};\nuse dep::std::mem::zeroed;\n\npub struct Fragment<let MAX_DATA_LEN: u32, T> {\n    pub offset: u32,\n    pub length: u32,\n    pub data: [T; MAX_DATA_LEN]\n}\n\nimpl<let MAX_DATA_LEN: u32, T> Fragment<MAX_DATA_LEN, T> {\n    pub fn empty() -> Fragment<MAX_DATA_LEN, T> {\n        Fragment { offset: 0, length: 0, data: std::mem::zeroed() }\n    }\n\n    pub fn new(offset: u32, length: u32, data: [T; MAX_DATA_LEN]) -> Fragment<MAX_DATA_LEN, T> {\n        assert(offset + length <= data.len(), \"Fragment length exceeds data length\");\n\n        Fragment { offset, length, data }\n    }\n\n    pub fn new_with_length(length: u32, data: [T; MAX_DATA_LEN]) -> Fragment<MAX_DATA_LEN, T> {\n        assert(length <= data.len(), \"Fragment length exceeds data length\");\n\n        Fragment { offset: 0, length, data }\n    }\n\n    pub fn from_array(data: [T; MAX_DATA_LEN]) -> Fragment<MAX_DATA_LEN, T> {\n        Fragment { offset: 0, length: data.len(), data }\n    }\n\n    pub fn from_array_resize<let DATA_LEN: u32>(data: [T; DATA_LEN]) -> Fragment<MAX_DATA_LEN, T> {\n        Fragment { offset: 0, length: data.len(), data: resize(data) }\n    }\n\n    pub fn to_array<let NEW_MAX_LEN: u32>(self) -> [T; NEW_MAX_LEN] {\n        self.focus().data\n    }\n\n    pub fn to_bounded_vec<let N: u32>(self) -> BoundedVec<T, N> {\n        assert(self.length <= N, \"Fragment length exceeds BoundedVec max length\");\n        let bounded_vec: &mut BoundedVec<T, N> = &mut BoundedVec::new();\n        self.each(|x, _| bounded_vec.push(x));\n\n        *bounded_vec\n    }\n\n    pub fn from_vec(vec: BoundedVec<T, MAX_DATA_LEN>) -> Fragment<MAX_DATA_LEN, T> {\n        Fragment::new_with_length(vec.len, vec.storage)\n    }\n\n    pub fn focus<let NEW_MAX_LEN: u32>(self) -> Fragment<NEW_MAX_LEN, T> {\n        assert(NEW_MAX_LEN >= self.length, \"New max length is smaller than fragment length\");\n\n        let mut new_data: [T; NEW_MAX_LEN] = std::mem::zeroed();\n        memcpy_up_to_length(&mut new_data, self.data, self.offset, self.length);\n\n        Fragment { offset: 0, length: self.length, data: new_data }\n    }\n\n    pub fn subfragment(self, offset: u32, length: u32) -> Fragment<MAX_DATA_LEN, T> {\n        assert(offset + length <= self.length, \"Subfragment overflows fragment\");\n\n        Fragment { offset: self.offset + offset, length, data: self.data }\n    }\n\n    pub fn is_empty(self) -> bool {\n        self.length == 0\n    }\n\n    pub fn at(self, index: u32) -> T {\n        assert(index < self.length, \"Index out of bounds\");\n\n        self.data[self.offset + index]\n    }\n\n    pub fn set(&mut self, index: u32, value: T) {\n        let length = self.length;\n        assert(\n            index < self.length, f\"Index out of bounds, tried to set at index {index} but the length is {length}\"\n        );\n\n        self.data[self.offset + index] = value;\n    }\n\n    pub fn pop_front(&mut self) -> T {\n        assert(!self.is_empty(), \"Cannot pop from an empty fragment\");\n        self.offset += 1;\n        self.length -= 1;\n        self.data[self.offset - 1]\n    }\n\n    pub fn pop_front_array<let LEN: u32>(&mut self) -> [T; LEN] {\n        assert(self.length >= LEN, \"Cannot pop array: fragment is too short\");\n        let mut res: [T; LEN] = std::mem::zeroed();\n        res.map(|_| self.pop_front())\n    }\n\n    pub fn pop_back(&mut self) -> T {\n        assert(!self.is_empty(), \"Cannot pop from an empty fragment\");\n        self.length -= 1;\n        self.data[self.offset + self.length]\n    }\n\n    pub fn push_back(&mut self, value: T) {\n        assert(self.offset + self.length + 1 <= MAX_DATA_LEN, \"Cannot push: fragment is full\");\n        self.data[self.offset + self.length] = value;\n        self.length += 1;\n    }\n\n    pub fn extend_back<let LEN: u32>(&mut self, other: [T; LEN]) {\n        for i in 0..LEN {\n            self.push_back(other[i]);\n        }\n    }\n\n    pub fn eq<let OTHER_MAX_DATA_LEN: u32>(self, other: Fragment<OTHER_MAX_DATA_LEN, T>) -> bool where T: Eq {\n        let res = &mut true;\n        if (self.length != other.length) {\n            *res = false;\n        }\n        self.each(\n            |el, i| {\n            if i < other.length {\n                *res &= el == other.at(i);\n            }\n        }\n        );\n\n        *res\n    }\n}\n\nimpl<let MAX_DATA_LEN: u32, T> Eq for Fragment<MAX_DATA_LEN, T> where T: Eq {\n    fn eq(self, other: Fragment<MAX_DATA_LEN, T>) -> bool {\n        let res = &mut true;\n        if self.length != other.length {\n            *res = false;\n        } else {\n            self.each(|el, i| {\n                *res &= el == other.at(i);\n            });\n        };\n\n        *res\n    }\n}\n\nimpl<let MAX_DATA_LEN: u32, T> Iterator<T> for Fragment<MAX_DATA_LEN, T> {\n    fn each<Env>(self, f: fn[Env](T, u32) -> ()) {\n        for i in 0..MAX_DATA_LEN {\n            if i < self.length {\n                f(self.at(i), i);\n            }\n        }\n    }\n}\n","path":"/home/drone/projects/rione/circuits/ethereum/circuits/lib/src/misc/fragment.nr"},"90":{"source":"use dep::std::wrapping_sub;\nuse crate::rlp::types::{RlpList, RlpFragment, RlpHeader, STRING, LIST};\nuse crate::misc::fragment::Fragment;\n\n// Maximum number of bytes required to represent entity length.\n// This means that this library can only decode RLP entities with a length of up to 2^16 - 1 bytes.\nglobal MAX_LEN_IN_BYTES: u32 = 2;\n\npub fn extract_payload_len<let N: u32>(data: Fragment<N, u8>, lenlen: u32) -> u32 {\n    assert(lenlen <= MAX_LEN_IN_BYTES, \"Length of length exceeds maximum\");\n    assert(lenlen <= data.length, \"Length of length exceeds input length\");\n    assert(lenlen != 0, \"Length of length is zero\");\n\n    let mut payload_length = 0;\n\n    for i in 0..MAX_LEN_IN_BYTES {\n        if (i < lenlen & i < data.length) {\n            payload_length = data.at(i) as u32 + payload_length * 256;\n        }\n    }\n\n    payload_length\n}\n\npub fn decode_to_rlp_header<let N: u32>(data: Fragment<N, u8>) -> RlpHeader {\n    let mut data = data;\n    let prefix = data.pop_front();\n\n    if (prefix < 0x80) { // single byte\n        RlpHeader { offset: 0, length: 1, data_type: STRING }\n    } else if (prefix < 0xb8) { // [0, 55] byte string\n        let offset = 1;\n        let length = wrapping_sub(prefix, 0x80) as u32;\n        assert(offset + length <= N, \"Decoded length of short string exceeds input length\");\n\n        RlpHeader { offset, length, data_type: STRING }\n    } else if (prefix < 0xc0) { // > 55 byte string\n        let offset = wrapping_sub(1 + prefix, 0xb7) as u32;\n        let length = extract_payload_len(data, wrapping_sub(prefix, 0xb7) as u32);\n        assert(offset + length <= N, \"Decoded length of long string exceeds input length\");\n\n        RlpHeader { offset, length, data_type: STRING }\n    } else if (prefix < 0xf8) { // [0, 55] byte list\n        let offset = 1;\n        let length = wrapping_sub(prefix, 0xc0) as u32;\n        assert(offset + length <= N, \"Decoded length of short list exceeds input length\");\n\n        RlpHeader { offset, length, data_type: LIST }\n    } else { // > 55 byte list\n        let offset = wrapping_sub(1 + prefix, 0xf7) as u32;\n        let length = extract_payload_len(data, wrapping_sub(prefix, 0xf7) as u32);\n        assert(offset + length <= N, \"Decoded length of long list exceeds input length\");\n\n        RlpHeader { offset, length, data_type: LIST }\n    }\n}\n\npub fn decode_string<let N: u32>(input: Fragment<N, u8>) -> RlpFragment {\n    let mut RlpHeader {offset, length, data_type} = decode_to_rlp_header(input);\n    let total_len = length + offset;\n    assert(total_len <= input.length, \"Total length exceeds input length\");\n\n    RlpFragment { offset, length, data_type: STRING }\n}\n\n// Strings are decoded and offsets point to the start of raw values, while list offsets point to the start of the RLP header.\npub fn decode_list<let N: u32, let MAX_FIELDS: u32>(data: Fragment<N, u8>) -> RlpList<MAX_FIELDS> {\n    let mut rlp_list: RlpList<MAX_FIELDS> = BoundedVec::new();\n\n    let RlpHeader {offset, length, data_type} = decode_to_rlp_header(data);\n    assert(data_type == LIST, \"Expected a list\");\n\n    let total_len = length + offset;\n    assert(total_len <= data.length, \"Total length exceeds input length\");\n\n    let mut current_offset = offset;\n    for _ in 0..MAX_FIELDS {\n        if (current_offset < total_len) {\n            let header: Fragment<N, u8> = data.subfragment(current_offset, data.length - current_offset);\n\n            let RlpHeader {offset: field_off, length: field_len, data_type: field_type} = decode_to_rlp_header(header);\n\n            let mut offset = current_offset;\n            let mut length = field_len;\n            if (field_type == STRING) {\n                offset += field_off;\n            } else {\n                length += field_off;\n            }\n\n            rlp_list.push(RlpFragment { offset, length, data_type: field_type });\n\n            current_offset += field_off + field_len;\n        }\n    }\n    assert(current_offset == total_len, \"Inconsistent rlp length\");\n\n    rlp_list\n}\n\n// The version of decode_list that is cheaper to call, but only works for lists of small strings (<= 55 bytes).\npub fn decode_list_of_small_strings<let N: u32, let NUM_FIELDS: u32>(data: Fragment<N, u8>) -> RlpList<NUM_FIELDS> {\n    let mut rlp_list: RlpList<NUM_FIELDS> = BoundedVec::new();\n\n    let RlpHeader {offset, length, data_type} = decode_to_rlp_header(data);\n    assert(data_type == LIST, \"Expected a list\");\n\n    let total_len = length + offset;\n    assert(total_len <= data.length, \"Total length exceeds input length\");\n\n    let mut current_offset = offset;\n    for _ in 0..NUM_FIELDS {\n        if (current_offset < total_len) {\n            let first_byte = data.at(current_offset);\n\n            let (field_off, field_len) = get_small_string_offset_and_length(first_byte);\n            rlp_list.push(RlpFragment { offset: current_offset + field_off, length: field_len, data_type: STRING });\n\n            current_offset += field_off + field_len;\n        }\n    }\n    assert(current_offset == total_len, \"Inconsistent rlp length\");\n\n    rlp_list\n}\n\npub fn get_small_string_offset_and_length(first_byte: u8) -> (u32, u32) {\n    assert(first_byte < 0xb8, \"Element is not a string of length < 56 bytes\");\n\n    if (first_byte < 0x80) {\n        (0, 1)\n    } else {\n        (1, wrapping_sub(first_byte as u32, 0x80))\n    }\n}\n","path":"/home/drone/projects/rione/circuits/ethereum/circuits/lib/src/rlp/decode.nr"},"91":{"source":"use crate::misc::{arrays::sub_array_equals_up_to_length, fragment::Fragment};\nuse crate::misc::bytes::byte_value;\nuse crate::misc::types::{Address, ADDRESS_LENGTH, Bytes32, BYTES32_LENGTH};\nuse dep::u2b::{u32_to_u8, u64_to_u8};\n\n// Enum for RLP data type\nglobal STRING: u32 = 0;\nglobal LIST: u32 = 1;\n\npub type RlpList<let MAX_FIELDS: u32> = BoundedVec<RlpFragment, MAX_FIELDS>;\n\npub struct RlpHeader {\n    pub offset: u32,\n    pub length: u32,\n    pub data_type: u32,\n}\n\nimpl Eq for RlpHeader {\n    fn eq(self, other: Self) -> bool {\n        (self.offset == other.offset)\n            & (self.length == other.length)\n            & (self.data_type == other.data_type)\n    }\n}\n\npub struct RlpFragment {\n    pub offset: u32,\n    pub length: u32,\n    pub data_type: u32,\n}\n\nimpl RlpFragment {\n    pub fn assert_eq_bytes<let FIELD_NAME_LEN: u32, let MAX_RLP_LEN: u32, let MAX_VALUE_LEN: u32>(\n        self,\n        field_name: str<FIELD_NAME_LEN>,\n        rlp: Fragment<MAX_RLP_LEN, u8>,\n        value: Fragment<MAX_VALUE_LEN, u8>,\n    ) {\n        assert(self.data_type == STRING, f\"{field_name}: Invalid RLP type\");\n        assert(self.length == value.length, f\"{field_name}: Invalid RLP length\");\n        assert(\n            rlp.subfragment(self.offset, self.length).eq(value),\n            f\"{field_name}: Invalid RLP value\",\n        );\n    }\n\n    pub fn assert_eq_bounded_vec<let FIELD_NAME_LEN: u32, let MAX_RLP_LEN: u32, let MAX_VALUE_LEN: u32>(\n        self,\n        field_name: str<FIELD_NAME_LEN>,\n        rlp: Fragment<MAX_RLP_LEN, u8>,\n        value: BoundedVec<u8, MAX_VALUE_LEN>,\n    ) {\n        self.assert_eq_bytes(field_name, rlp, Fragment::from_vec(value));\n    }\n\n    pub fn assert_empty_string<let FIELD_NAME_LEN: u32, let MAX_RLP_LEN: u32>(\n        self,\n        field_name: str<FIELD_NAME_LEN>,\n    ) {\n        assert(self.data_type == STRING, f\"{field_name}: Invalid RLP type\");\n        assert(self.length == 0, f\"{field_name}: Expected empty string\");\n    }\n\n    pub fn assert_eq_u1<let FIELD_NAME_LEN: u32, let MAX_RLP_LEN: u32>(\n        self,\n        field_name: str<FIELD_NAME_LEN>,\n        rlp: Fragment<MAX_RLP_LEN, u8>,\n        value: u1,\n    ) {\n        self.assert_eq_bytes(field_name, rlp, Fragment::from_array([value as u8]));\n    }\n\n    pub fn assert_eq_u8<let FIELD_NAME_LEN: u32, let MAX_RLP_LEN: u32>(\n        self,\n        field_name: str<FIELD_NAME_LEN>,\n        rlp: Fragment<MAX_RLP_LEN, u8>,\n        value: u8,\n    ) {\n        self.assert_eq_bounded_vec(field_name, rlp, byte_value([value]));\n    }\n\n    pub fn assert_eq_u32<let FIELD_NAME_LEN: u32, let MAX_RLP_LEN: u32>(\n        self,\n        field_name: str<FIELD_NAME_LEN>,\n        rlp: Fragment<MAX_RLP_LEN, u8>,\n        value: u32,\n    ) {\n        self.assert_eq_bounded_vec(field_name, rlp, byte_value(u32_to_u8(value)));\n    }\n\n    pub fn assert_eq_u64<let FIELD_NAME_LEN: u32, let MAX_RLP_LEN: u32>(\n        self,\n        field_name: str<FIELD_NAME_LEN>,\n        rlp: Fragment<MAX_RLP_LEN, u8>,\n        value: u64,\n    ) {\n        self.assert_eq_bounded_vec(field_name, rlp, byte_value(u64_to_u8(value)));\n    }\n\n    pub fn assert_eq_u128<let FIELD_NAME_LEN: u32, let MAX_RLP_LEN: u32>(\n        self,\n        field_name: str<FIELD_NAME_LEN>,\n        rlp: Fragment<MAX_RLP_LEN, u8>,\n        value: U128,\n    ) {\n        self.assert_eq_bounded_vec(field_name, rlp, byte_value(value.to_be_bytes()));\n    }\n\n    pub fn assert_eq_address<let FIELD_NAME_LEN: u32, let MAX_RLP_LEN: u32>(\n        self,\n        field_name: str<FIELD_NAME_LEN>,\n        rlp: Fragment<MAX_RLP_LEN, u8>,\n        value: Address,\n    ) {\n        self.assert_eq_bytes(field_name, rlp, Fragment::from_array(value));\n    }\n\n    pub fn assert_eq_bytes32<let FIELD_NAME_LEN: u32, let MAX_RLP_LEN: u32>(\n        self,\n        field_name: str<FIELD_NAME_LEN>,\n        rlp: Fragment<MAX_RLP_LEN, u8>,\n        value: Bytes32,\n    ) {\n        self.assert_eq_bytes(field_name, rlp, Fragment::from_array(value));\n    }\n}\n\nimpl Default for RlpFragment {\n    fn default() -> Self {\n        RlpFragment { offset: 0, length: 0, data_type: 0 }\n    }\n}\n\nimpl Eq for RlpFragment {\n    fn eq(self, other: Self) -> bool {\n        (self.offset == other.offset)\n            & (self.length == other.length)\n            & (self.data_type == other.data_type)\n    }\n}\n","path":"/home/drone/projects/rione/circuits/ethereum/circuits/lib/src/rlp/types.nr"},"93":{"source":"use crate::account::AccountWithinBlock;\nuse crate::account_with_storage::{StorageWithinBlock, Account};\nuse crate::constants::{SR_MAX_DEPTH_NO_LEAF, SR_MAX_PREFIXED_KEY_NIBBLE_LEN, SR_MAX_LEAF_LEN_M, SR_MAX_VALUE_LEN_M};\nuse crate::account::{\n    MAX_ACCOUNT_DEPTH_NO_LEAF_M, MAX_PREFIXED_KEY_NIBBLE_LEN as ACCOUNT_MAX_PREFIXED_KEY_NIBBLE_LEN,\n    MAX_ACCOUNT_STATE_LEN, MAX_ACCOUNT_LEAF_LEN\n};\nuse crate::account_with_storage::{\n    MAX_PREFIXED_KEY_NIBBLE_LEN as STORAGE_MAX_PREFIXED_KEY_NIBBLE_LEN, MAX_STORAGE_DEPTH_NO_LEAF_M,\n    MAX_STORAGE_VALUE_LEN, MAX_STORAGE_LEAF_LEN\n};\nuse crate::misc::{fragment::Fragment, types::{BYTES32_LENGTH, Bytes32, ADDRESS_LENGTH, Address}};\nuse crate::uint256::U256;\nuse crate::merkle_patricia_proofs::proof::{ProofInput, Proof, Node, Leaf, MAX_NODE_LEN};\nuse dep::std::mem::zeroed;\n\ntrait Serde<let LEN: u32> {\n    fn serialize(self) -> [Field; LEN];\n    fn deserialize(data: [Field; LEN]) -> Self;\n}\n\nglobal U128_SERIALIZED_LEN: u32 = 2;\n\nimpl Serde<U128_SERIALIZED_LEN> for U128 {\n    fn serialize(self) -> [Field; U128_SERIALIZED_LEN] {\n        [self.lo, self.hi]\n    }\n\n    fn deserialize(data: [Field; U128_SERIALIZED_LEN]) -> Self {\n        U128 { lo: data[0], hi: data[1] }\n    }\n}\n\nglobal U256_SERIALIZED_LEN: u32 = 4;\n\nimpl Serde<U256_SERIALIZED_LEN> for U256 {\n    fn serialize(self) -> [Field; U256_SERIALIZED_LEN] {\n        [self.low.lo, self.low.hi, self.high.lo, self.high.hi]\n    }\n\n    fn deserialize(data: [Field; U256_SERIALIZED_LEN]) -> Self {\n        U256 { low: U128 { lo: data[0], hi: data[1] }, high: U128 { lo: data[2], hi: data[3] } }\n    }\n}\n\nimpl<let LEN: u32> Serde<LEN> for [u8; LEN] {\n    fn serialize(self) -> [Field; LEN] {\n        let mut result: [Field; LEN] = zeroed();\n        for i in 0..LEN {\n            result[i] = self[i] as Field;\n        }\n        result\n    }\n\n    fn deserialize(data: [Field; LEN]) -> Self {\n        let mut result: [u8; LEN] = zeroed();\n        for i in 0..LEN {\n            result[i] = data[i] as u8;\n        }\n        result\n    }\n}\n\nglobal ACCOUNT_LEN: u32 = 1 + 1 + BYTES32_LENGTH + BYTES32_LENGTH;\n\nimpl Serde<ACCOUNT_LEN> for Account {\n    fn serialize(self) -> [Field; ACCOUNT_LEN] {\n        let mut data: BoundedVec<Field, ACCOUNT_LEN> = BoundedVec::new();\n        data.push(self.nonce as Field);\n        data.push(self.balance);\n        data.extend_from_array(self.storage_root.serialize());\n        data.extend_from_array(self.code_hash.serialize());\n        data.storage\n    }\n\n    fn deserialize(data: [Field; ACCOUNT_LEN]) -> Self {\n        let mut fragment = Fragment::from_array(data);\n        let nonce = fragment.pop_front() as u64;\n        let balance = fragment.pop_front();\n        let storage_root: Bytes32 = fragment.pop_front_array().deserialize();\n        let code_hash: Bytes32 = fragment.pop_front_array().deserialize();\n        Account {\n            nonce,\n            balance,\n            storage_root,\n            code_hash,\n        }\n    }\n}\n\nglobal ACCOUNT_BLOCK_LEN: u32 = ACCOUNT_LEN + BYTES32_LENGTH;\n\nimpl Serde<ACCOUNT_BLOCK_LEN> for AccountWithinBlock {\n    fn serialize(self) -> [Field; ACCOUNT_BLOCK_LEN] {\n        let mut data: BoundedVec<Field, ACCOUNT_BLOCK_LEN> = BoundedVec::new();\n        data.extend_from_array(self.account.serialize());\n        data.extend_from_array(self.block_hash.serialize());\n        data.storage\n    }\n\n    fn deserialize(data: [Field; ACCOUNT_BLOCK_LEN]) -> Self {\n        let mut fragment = Fragment::from_array(data);\n        let account = Account::deserialize(fragment.pop_front_array());\n        let block_hash = fragment.pop_front_array().deserialize();\n        AccountWithinBlock {\n            account,\n            block_hash,\n        }\n    }\n}\n\nglobal STORAGE_BLOCK_LEN: u32 = BYTES32_LENGTH + ACCOUNT_LEN + BYTES32_LENGTH;\n\nimpl Serde<STORAGE_BLOCK_LEN> for StorageWithinBlock<1> {\n    fn serialize(self) -> [Field; STORAGE_BLOCK_LEN] {\n        let mut data: BoundedVec<Field, STORAGE_BLOCK_LEN> = BoundedVec::new();\n        data.extend_from_array(self.block_hash.serialize());\n        data.extend_from_array(self.account.serialize());\n        data.extend_from_array(self.values[0].serialize());\n        data.storage\n    }\n\n    fn deserialize(data: [Field; STORAGE_BLOCK_LEN]) -> Self {\n        let mut fragment = Fragment::from_array(data);\n        let block_hash = fragment.pop_front_array().deserialize();\n        let account = Account::deserialize(fragment.pop_front_array());\n        let values = [fragment.pop_front_array().deserialize()];\n        StorageWithinBlock {\n            block_hash,\n            account,\n            values,\n        }\n    }\n}\n\n/** STATE PROOF INPUT **/\n\nglobal STATE_NODES_LEN_M: u32 = 5320; // MAX_NODE_LEN * MAX_ACCOUNT_DEPTH_NO_LEAF_M\n\npub fn serialize_state_nodes(nodes: [Node; MAX_ACCOUNT_DEPTH_NO_LEAF_M]) -> [Field; STATE_NODES_LEN_M] {\n    let mut data: BoundedVec<Field, STATE_NODES_LEN_M> = BoundedVec::new();\n    for i in 0..MAX_ACCOUNT_DEPTH_NO_LEAF_M {\n        data.extend_from_array(nodes[i].serialize());\n    }\n    data.storage\n}\n\npub fn deserialize_state_nodes(data: [Field; STATE_NODES_LEN_M]) -> [Node; MAX_ACCOUNT_DEPTH_NO_LEAF_M] {\n    let mut result: Fragment<MAX_ACCOUNT_DEPTH_NO_LEAF_M, Node> = Fragment::empty();\n    let mut fragment = Fragment::from_array(data);\n    for _ in 0..MAX_ACCOUNT_DEPTH_NO_LEAF_M {\n        let node: Node = fragment.pop_front_array().deserialize();\n        result.push_back(node);\n    }\n    result.data\n}\n\nglobal STATE_PROOF_LEN_M: u32 = 5469; // STATE_NODES_LEN_M + MAX_ACCOUNT_LEAF_LEN + 1\n\nimpl Serde<STATE_PROOF_LEN_M> for Proof<MAX_ACCOUNT_DEPTH_NO_LEAF_M, MAX_ACCOUNT_LEAF_LEN> {\n    fn serialize(self) -> [Field; STATE_PROOF_LEN_M] {\n        let mut data: BoundedVec<Field, STATE_PROOF_LEN_M> = BoundedVec::new();\n        data.extend_from_array(serialize_state_nodes(self.nodes));\n        data.extend_from_array(self.leaf.serialize());\n        data.push(self.depth as Field);\n        data.storage\n    }\n\n    fn deserialize(data: [Field; STATE_PROOF_LEN_M]) -> Self {\n        let mut fragment = Fragment::from_array(data);\n        let nodes = deserialize_state_nodes(fragment.pop_front_array());\n        let leaf = fragment.pop_front_array().deserialize();\n        let depth = fragment.pop_front() as u64;\n        Proof {\n            nodes,\n            leaf,\n            depth,\n        }\n    }\n}\n\nglobal STATE_PROOF_INPUT_LEN_M: u32 = 5645; // ACCOUNT_MAX_PREFIXED_KEY_NIBBLE_LEN + MAX_ACCOUNT_STATE_LEN + STATE_PROOF_LEN_M\n\nimpl Serde<STATE_PROOF_INPUT_LEN_M> for ProofInput<ACCOUNT_MAX_PREFIXED_KEY_NIBBLE_LEN, MAX_ACCOUNT_STATE_LEN, MAX_ACCOUNT_DEPTH_NO_LEAF_M, MAX_ACCOUNT_LEAF_LEN> {\n    fn serialize(self) -> [Field; STATE_PROOF_INPUT_LEN_M] {\n        let mut data: BoundedVec<Field, STATE_PROOF_INPUT_LEN_M> = BoundedVec::new();\n        data.extend_from_array(self.key.serialize());\n        data.extend_from_array(self.value.serialize());\n        data.extend_from_array(self.proof.serialize());\n        data.storage\n    }\n\n    fn deserialize(data: [Field; STATE_PROOF_INPUT_LEN_M]) -> Self {\n        let mut fragment = Fragment::from_array(data);\n        let key = fragment.pop_front_array().deserialize();\n        let value = fragment.pop_front_array().deserialize();\n        let proof = Serde::<STATE_PROOF_LEN_M>::deserialize(fragment.pop_front_array());\n        ProofInput {\n            key,\n            value,\n            proof\n        }\n    }\n}\n\n/** STORAGE PROOF INPUT **/\n\nglobal STORAGE_NODES_LEN_M: u32 = 3192; // MAX_NODE_LEN * MAX_STORAGE_DEPTH_NO_LEAF_M\n\npub fn serialize_storage_nodes(nodes: [Node; MAX_STORAGE_DEPTH_NO_LEAF_M]) -> [Field; STORAGE_NODES_LEN_M] {\n    let mut data: BoundedVec<Field, STORAGE_NODES_LEN_M> = BoundedVec::new();\n    for i in 0..MAX_STORAGE_DEPTH_NO_LEAF_M {\n        data.extend_from_array(nodes[i].serialize());\n    }\n    data.storage\n}\n\npub fn deserialize_storage_nodes(data: [Field; STORAGE_NODES_LEN_M]) -> [Node; MAX_STORAGE_DEPTH_NO_LEAF_M] {\n    let mut result: Fragment<MAX_STORAGE_DEPTH_NO_LEAF_M, Node> = Fragment::empty();\n    let mut fragment = Fragment::from_array(data);\n    for _ in 0..MAX_STORAGE_DEPTH_NO_LEAF_M {\n        let node: Node = fragment.pop_front_array().deserialize();\n        result.push_back(node);\n    }\n    result.data\n}\n\nglobal STORAGE_PROOF_LEN_M: u32 = 3262; // STORAGE_NODES_LEN_M + MAX_STORAGE_LEAF_LEN + 1\n\nimpl Serde<STORAGE_PROOF_LEN_M> for Proof<MAX_STORAGE_DEPTH_NO_LEAF_M, MAX_STORAGE_LEAF_LEN> {\n    fn serialize(self) -> [Field; STORAGE_PROOF_LEN_M] {\n        let mut data: BoundedVec<Field, STORAGE_PROOF_LEN_M> = BoundedVec::new();\n        data.extend_from_array(serialize_storage_nodes(self.nodes));\n        data.extend_from_array(self.leaf.serialize());\n        data.push(self.depth as Field);\n        data.storage\n    }\n\n    fn deserialize(data: [Field; STORAGE_PROOF_LEN_M]) -> Self {\n        let mut fragment = Fragment::from_array(data);\n        let nodes = deserialize_storage_nodes(fragment.pop_front_array());\n        let leaf = fragment.pop_front_array().deserialize();\n        let depth = fragment.pop_front() as u64;\n        Proof {\n            nodes,\n            leaf,\n            depth,\n        }\n    }\n}\n\nglobal STORAGE_PROOF_INPUT_LEN_M: u32 = 3360; // STORAGE_MAX_PREFIXED_KEY_NIBBLE_LEN + MAX_STORAGE_VALUE_LEN + STORAGE_PROOF_LEN_M\n\nimpl Serde<STORAGE_PROOF_INPUT_LEN_M> for ProofInput<STORAGE_MAX_PREFIXED_KEY_NIBBLE_LEN, MAX_STORAGE_VALUE_LEN, MAX_STORAGE_DEPTH_NO_LEAF_M, MAX_STORAGE_LEAF_LEN> {\n    fn serialize(self) -> [Field; STORAGE_PROOF_INPUT_LEN_M] {\n        let mut data: BoundedVec<Field, STORAGE_PROOF_INPUT_LEN_M> = BoundedVec::new();\n        data.extend_from_array(self.key.serialize());\n        data.extend_from_array(self.value.serialize());\n        data.extend_from_array(self.proof.serialize());\n        data.storage\n    }\n\n    fn deserialize(data: [Field; STORAGE_PROOF_INPUT_LEN_M]) -> Self {\n        let mut fragment = Fragment::from_array(data);\n        let key = fragment.pop_front_array().deserialize();\n        let value = fragment.pop_front_array().deserialize();\n        let proof = Serde::<STORAGE_PROOF_LEN_M>::deserialize(fragment.pop_front_array());\n        ProofInput {\n            key,\n            value,\n            proof\n        }\n    }\n}\n\n/** RECEIPT PROOF INPUT **/\n\nglobal RECEIPT_NODES_LEN_M: u32 = 3192; // MAX_NODE_LEN * SR_MAX_DEPTH_NO_LEAF\n\npub fn serialize_receipt_nodes(nodes: [Node; SR_MAX_DEPTH_NO_LEAF]) -> [Field; RECEIPT_NODES_LEN_M] {\n    let mut data: BoundedVec<Field, RECEIPT_NODES_LEN_M> = BoundedVec::new();\n    for i in 0..SR_MAX_DEPTH_NO_LEAF {\n        data.extend_from_array(nodes[i].serialize());\n    }\n    data.storage\n}\n\npub fn deserialize_receipt_nodes(data: [Field; RECEIPT_NODES_LEN_M]) -> [Node; SR_MAX_DEPTH_NO_LEAF] {\n    let mut result: Fragment<SR_MAX_DEPTH_NO_LEAF, Node> = Fragment::empty();\n    let mut fragment = Fragment::from_array(data);\n    for _ in 0..SR_MAX_DEPTH_NO_LEAF {\n        let node: Node = fragment.pop_front_array().deserialize();\n        result.push_back(node);\n    }\n    result.data\n}\n\nglobal RECEIPT_PROOF_LEN_M: u32 = 3262; // RECEIPT_NODES_LEN_M + SR_MAX_LEAF_LEN_M + 1\n\nimpl Serde<RECEIPT_PROOF_LEN_M> for Proof<SR_MAX_DEPTH_NO_LEAF, SR_MAX_LEAF_LEN_M> {\n    fn serialize(self) -> [Field; RECEIPT_PROOF_LEN_M] {\n        let mut data: BoundedVec<Field, RECEIPT_PROOF_LEN_M> = BoundedVec::new();\n        data.extend_from_array(serialize_receipt_nodes(self.nodes));\n        data.extend_from_array(self.leaf.serialize());\n        data.push(self.depth as Field);\n        data.storage\n    }\n\n    fn deserialize(data: [Field; RECEIPT_PROOF_LEN_M]) -> Self {\n        let mut fragment = Fragment::from_array(data);\n        let nodes = deserialize_receipt_nodes(fragment.pop_front_array());\n        let leaf = fragment.pop_front_array().deserialize();\n        let depth = fragment.pop_front() as u64;\n        Proof {\n            nodes,\n            leaf,\n            depth,\n        }\n    }\n}\n\nglobal RECEIPT_PROOF_INPUT_LEN_M: u32 = 3360; // SR_MAX_PREFIXED_KEY_NIBBLE_LEN + SR_MAX_VALUE_LEN_M + RECEIPT_PROOF_LEN_M\n\nimpl Serde<RECEIPT_PROOF_INPUT_LEN_M> for ProofInput<SR_MAX_PREFIXED_KEY_NIBBLE_LEN, SR_MAX_VALUE_LEN_M, SR_MAX_DEPTH_NO_LEAF, SR_MAX_LEAF_LEN_M> {\n    fn serialize(self) -> [Field; RECEIPT_PROOF_INPUT_LEN_M] {\n        let mut data: BoundedVec<Field, RECEIPT_PROOF_INPUT_LEN_M> = BoundedVec::new();\n        data.extend_from_array(self.key.serialize());\n        data.extend_from_array(self.value.serialize());\n        data.extend_from_array(self.proof.serialize());\n        data.storage\n    }\n\n    fn deserialize(data: [Field; RECEIPT_PROOF_INPUT_LEN_M]) -> Self {\n        let mut fragment = Fragment::from_array(data);\n        let key = fragment.pop_front_array().deserialize();\n        let value = fragment.pop_front_array().deserialize();\n        let proof = Serde::<RECEIPT_PROOF_LEN_M>::deserialize(fragment.pop_front_array());\n        ProofInput {\n            key,\n            value,\n            proof\n        }\n    }\n}\n\n/** TRANSACTION PROOF INPUT **/\npub global TX_PROOF_INPUT_LEN_M: u32 = 3360;  // Same as RECEIPT_PROOF_INPUT_LEN_M for now\n","path":"/home/drone/projects/rione/circuits/ethereum/circuits/lib/src/serde.nr"},"96":{"source":"use crate::account::{Account, MAX_PREFIXED_KEY_NIBBLE_LEN, MAX_ACCOUNT_STATE_LEN, MAX_ACCOUNT_LEAF_LEN};\nuse crate::misc::{types::{Address, ADDRESS_LENGTH}, bytes::right_pad, fragment::Fragment};\nuse crate::rlp::decode::decode_list_of_small_strings;\nuse crate::rlp::types::RlpList;\nuse crate::merkle_patricia_proofs::proof::{ProofInput, verify_merkle_proof};\nuse crate::HASH_LEN;\n\nuse dep::std::hash::keccak256;\n\nglobal ACCOUNT_FIELDS_COUNT: u32 = 4;\nglobal NONCE_INDEX: u32 = 0;\nglobal BALANCE_INDEX: u32 = 1;\nglobal STORAGE_ROOT_INDEX: u32 = 2;\nglobal CODE_HASH_INDEX: u32 = 3;\n\npub(crate) fn assert_account_equals(account_rlp_left_padded: [u8; MAX_ACCOUNT_STATE_LEN], account: Account) {\n    let account_rlp_right_padded = right_pad(account_rlp_left_padded).storage;\n    let account_rlp_list: RlpList<ACCOUNT_FIELDS_COUNT> = decode_list_of_small_strings(Fragment::from_array(account_rlp_right_padded));\n    assert(account_rlp_list.len == ACCOUNT_FIELDS_COUNT, \"Invalid number of fields in account RLP\");\n\n    let account_rlp = Fragment::from_array(account_rlp_right_padded);\n    account_rlp_list.get(NONCE_INDEX).assert_eq_u64(\"Nonce\", account_rlp, account.nonce);\n    account_rlp_list.get(BALANCE_INDEX).assert_eq_u128(\"Balance\", account_rlp, U128::from_integer(account.balance));\n\n    account_rlp_list.get(STORAGE_ROOT_INDEX).assert_eq_bytes32(\"Storage root\", account_rlp, account.storage_root);\n    account_rlp_list.get(CODE_HASH_INDEX).assert_eq_bytes32(\"Code hash\", account_rlp, account.code_hash);\n}\n\nfn assert_address_equals(address_hash: [u8; MAX_PREFIXED_KEY_NIBBLE_LEN], address: Address) {\n    let address_hash_fragment = Fragment::new(MAX_PREFIXED_KEY_NIBBLE_LEN - HASH_LEN, HASH_LEN, address_hash);\n    let other_address_hash_fragment = Fragment::from_array(keccak256(address, ADDRESS_LENGTH as u32));\n    assert(address_hash_fragment.eq(other_address_hash_fragment), \"Address mismatch\");\n}\n\npub fn verify_account<let MAX_DEPTH_NO_LEAF: u32>(\n    address: Address,\n    account: Account,\n    state_proof_input: ProofInput<MAX_PREFIXED_KEY_NIBBLE_LEN, MAX_ACCOUNT_STATE_LEN, MAX_DEPTH_NO_LEAF, MAX_ACCOUNT_LEAF_LEN>,\n    state_root: [u8; HASH_LEN]\n) {\n    assert_address_equals(state_proof_input.key, address);\n    assert_account_equals(state_proof_input.value, account);\n    verify_merkle_proof(\n        state_proof_input.key,\n        state_proof_input.value,\n        state_root,\n        state_proof_input.proof\n    );\n}\n","path":"/home/drone/projects/rione/circuits/ethereum/circuits/lib/src/verifiers/account.nr"},"97":{"source":"use dep::std::hash::keccak256;\n\nuse crate::chain::{ETHEREUM_MAINNET_ID, ETHEREUM_SEPOLIA_ID};\nuse crate::HASH_LEN;\nuse crate::header::{BlockHeaderPartial, BlockHeaderRlp};\nuse crate::misc::{arrays::sub_array_equals, fragment::Fragment};\nuse crate::rlp::decode::decode_list;\nuse crate::rlp::types::RlpList;\n\nglobal MAX_HEADER_FIELDS_COUNT: u32 = 20;\nglobal STATE_ROOT_INDEX: u32 = 3;\nglobal TRANSACTIONS_ROOT_INDEX: u32 = 4;\nglobal RECEIPTS_ROOT_INDEX: u32 = 5;\nglobal BLOCK_NUM_INDEX: u32 = 8;\n\nglobal LONDON_BLOCK_NUM: u64 = 12_965_000;\nglobal PARIS_BLOCK_NUM: u64 = 15_537_394;\nglobal CANCUN_BLOCK_NUM: u64 = 19_426_587;\n\npub(crate) fn get_header_fields_count(chain_id: Field, block_number: u64) -> u32 {\n    let mut fields_count = 15;\n    if chain_id == ETHEREUM_MAINNET_ID {\n        fields_count = 20;\n    } else if chain_id == ETHEREUM_SEPOLIA_ID {\n        fields_count = 20;\n    } else {\n        assert(false, \"Unsupported chain ID\");\n    }\n    \n    fields_count\n}\n\npub fn verify_header(\n    chain_id: Field,\n    block_header_partial: BlockHeaderPartial,\n    block_header_rlp: BlockHeaderRlp,\n) {\n    let block_header_rlp = Fragment::from_vec(block_header_rlp);\n    let header_rlp_list: RlpList<MAX_HEADER_FIELDS_COUNT> = decode_list(block_header_rlp);\n    let expected_header_fields_count =\n        get_header_fields_count(chain_id, block_header_partial.number);\n\n    assert(\n        expected_header_fields_count == header_rlp_list.len,\n        \"number of header RLP fields does not match\",\n    );\n\n    header_rlp_list.get(BLOCK_NUM_INDEX).assert_eq_u64(\n        \"Block number\",\n        block_header_rlp,\n        block_header_partial.number,\n    );\n    header_rlp_list.get(STATE_ROOT_INDEX).assert_eq_bytes32(\n        \"State root\",\n        block_header_rlp,\n        block_header_partial.state_root,\n    );\n    header_rlp_list.get(TRANSACTIONS_ROOT_INDEX).assert_eq_bytes32(\n        \"Transactions root\",\n        block_header_rlp,\n        block_header_partial.transactions_root,\n    );\n    header_rlp_list.get(RECEIPTS_ROOT_INDEX).assert_eq_bytes32(\n        \"Receipts root\",\n        block_header_rlp,\n        block_header_partial.receipts_root,\n    );\n\n   \n}\n","path":"/home/drone/projects/rione/circuits/ethereum/circuits/lib/src/verifiers/header.nr"},"100":{"source":"use crate::misc::types::Bytes32;\nuse crate::account::MAX_PREFIXED_KEY_NIBBLE_LEN;\nuse crate::account_with_storage::{MAX_STORAGE_VALUE_LEN, MAX_STORAGE_LEAF_LEN};\nuse crate::merkle_patricia_proofs::proof::{ProofInput, verify_merkle_proof};\nuse crate::header::{BlockHeaderPartial, get_header};\n\npub fn verify_storage_values<let N: u32, let MAX_STORAGE_DEPTH_NO_LEAF: u32>(\n    proof_inputs: [ProofInput<MAX_PREFIXED_KEY_NIBBLE_LEN, MAX_STORAGE_VALUE_LEN, MAX_STORAGE_DEPTH_NO_LEAF, MAX_STORAGE_LEAF_LEN>; N],\n    storage_root: Bytes32\n) {\n    for i in 0..N {\n        let proof_input = proof_inputs[i];\n        verify_merkle_proof(\n            proof_input.key,\n            proof_input.value,\n            storage_root,\n            proof_input.proof\n        );\n    }\n}\n\npub fn verify_storage_values_against_block<let N: u32, let MAX_STORAGE_DEPTH_NO_LEAF: u32>(\n    chain_id: Field,\n    block_number: u64,\n    proof_inputs: [ProofInput<MAX_PREFIXED_KEY_NIBBLE_LEN, MAX_STORAGE_VALUE_LEN, MAX_STORAGE_DEPTH_NO_LEAF, MAX_STORAGE_LEAF_LEN>; N],\n    storage_root: Bytes32\n) {\n\n    let header = unsafe { get_header(chain_id, block_number) };\n    \n    assert(header.number == block_number, \"Block number mismatch in storage verification\");\n    \n    verify_storage_values(proof_inputs, storage_root);\n}\n","path":"/home/drone/projects/rione/circuits/ethereum/circuits/lib/src/verifiers/storage.nr"},"107":{"source":"pub fn u32_to_u8(num: u32) -> [u8; 4] {\n    let mut out: [u8; 4] = [0; 4];\n    for i in 0..4 {\n        let shift: u8 = (24 - (i * 8));\n        out[i] = (num >> shift) as u8;\n    }\n\n    out\n}\n\n#[test]\nfn test_u32() {\n    let small = u32_to_u8(10);\n    assert(small.len() == 4);\n    assert(small[0] == 0);\n    assert(small[1] == 0);\n    assert(small[2] == 0);\n    assert(small[3] == 10);\n\n    let two_byte = u32_to_u8(256);\n    assert(two_byte[0] == 0x00);\n    assert(two_byte[1] == 0x00);\n    assert(two_byte[2] == 0x01);\n    assert(two_byte[3] == 0x00);\n\n    let ceil = u32_to_u8(4294967295);\n    assert(ceil[0] == 0xff);\n    assert(ceil[1] == 0xff);\n    assert(ceil[2] == 0xff);\n    assert(ceil[3] == 0xff);\n}\n\npub fn u64_to_u8(num: u64) -> [u8; 8] {\n    let mut out: [u8; 8] = [0; 8];\n    for i in 0..8 {\n        let shift: u8 = 56 - (i * 8);\n        out[i] = (num >> shift) as u8;\n    }\n\n    out\n}\n\n#[test]\nfn test_u64() {\n    let small = u64_to_u8(10);\n    assert(small.len() == 8);\n    assert(small[0] == 0);\n    assert(small[1] == 0);\n    assert(small[2] == 0);\n    assert(small[3] == 0);\n    assert(small[4] == 0);\n    assert(small[5] == 0);\n    assert(small[6] == 0);\n    assert(small[7] == 10);\n\n    let two_byte = u64_to_u8(256);\n    assert(two_byte[0] == 0x00);\n    assert(two_byte[1] == 0x00);\n    assert(two_byte[2] == 0x00);\n    assert(two_byte[3] == 0x00);\n    assert(two_byte[4] == 0x00);\n    assert(two_byte[5] == 0x00);\n    assert(two_byte[6] == 0x01);\n    assert(two_byte[7] == 0x00);\n\n    let random = u64_to_u8(0x1cbe443030);\n    assert(random[0] == 0x00);\n    assert(random[1] == 0x00);\n    assert(random[2] == 0x00);\n    assert(random[3] == 0x1c);\n    assert(random[4] == 0xbe);\n    assert(random[5] == 0x44);\n    assert(random[6] == 0x30);\n    assert(random[7] == 0x30);\n\n    let ceil = u64_to_u8(18446744073709551615);\n    assert(ceil[0] == 0xff);\n    assert(ceil[1] == 0xff);\n    assert(ceil[2] == 0xff);\n    assert(ceil[3] == 0xff);\n    assert(ceil[4] == 0xff);\n    assert(ceil[5] == 0xff);\n    assert(ceil[6] == 0xff);\n    assert(ceil[7] == 0xff);\n}\n","path":"/home/drone/nargo/github.com/vlayer-xyz/noir-u2b/v0.3.4/src/lib.nr"},"110":{"source":"use crate::bn254::ks;\n\n//encrypts up to 8000 Field Elements\n#[field(bn254)]\npub fn encrypt<let R: u32>(plains: [Field; R], key:[Field; 4],  iv:[Field; 4]) -> [Field; R] {\n    let mut ciphers = [0; R];\n    let (mut state, extended_key) = ks::hydra_body(key, iv);\n    let mut ks = ks::hydra_first_head(state, extended_key);\n    if R <= 8 as u32 {\n        for i in 0..R {\n            ciphers[i] = plains[i] + ks[i];\n        }\n    } else {\n        for i in 0..8 {\n            ciphers[i] = plains[i] + ks[i];\n        }\n        for i in 8..R {\n            let off = i % 8;\n            if off == 0 {\n                let result = ks::hydra_head(state, extended_key, off);\n                state = result.0;\n                ks = result.1;\n            }\n            ciphers[i] = plains[i] + ks[off];\n        }\n    }\n    ciphers\n}\n","path":"/home/drone/projects/rione/circuits/lib/noir-hydra/src/bn254/enc.nr"},"111":{"source":"use crate::bn254::consts;\n\n#[field(bn254)]\npub(crate) fn hydra_body(key: [Field; 4], iv: [Field; 4]) -> ([Field; 8], [Field; 8]) {\n    let (mut state, z) = permutation_b(vec_add(iv, key));\n    state = vec_add(state, key);\n    (vec_concat(state, z), vec_concat(key, matrix_e(key)))\n}\n\n#[field(bn254)]\npub(crate) fn hydra_first_head<let R: u32>(state: [Field; 8], key: [Field; 8]) ->  [Field; 8] {\n    vec_add(permutation_h(state, key), state)\n}\n\n#[field(bn254)]\npub(crate) fn hydra_head<let R: u32>(state: [Field; 8], key: [Field; 8], index: u32) -> ([Field; 8], [Field; 8]) {\n    let roll = rolling(state, index);\n    (roll, vec_add(permutation_h(roll, key), roll))\n}\n\n\nfn rolling(state: [Field; 8], index: u32) -> [Field; 8] {\n    let (y, z) = vec_split(state);\n    let (y, z) = non_linear_r(y, z);\n    let y_perm = matrix_i(y, consts::Mi);\n    let z_perm = matrix_i(z, consts::Mi);\n    vec_add(vec_concat(y_perm, z_perm), consts::rc_r[index])\n}\n\nfn permutation_h(mut roll: [Field; 8], extended_key: [Field; 8]) -> [Field; 8] {\n    for i in 0..consts::Rh {\n        roll = non_linear_h(roll);\n        roll = matrix_i(roll, consts::Mh);\n        roll = vec_add(roll, consts::rc_h[i]);\n        roll = vec_add(roll, extended_key);\n    }\n    roll\n}\n\nfn permutation_b(state: [Field; 4]) -> ([Field;4], [Field; 4]) {\n    let mut acc = [0; 4];\n    let mut state = matrix_e(state);\n    for i in 0..consts::Re_1 {\n        state = non_linear_e(state);\n        state = matrix_e(state);\n        state = vec_add(state, consts::rc_b[i]);\n        acc = vec_add(acc, state);\n    }\n    for i in 0..consts::Ri {\n        state = non_linear_i(state);\n        state = matrix_i(state, consts::Mi);\n        state = vec_add(state, consts::rc_b[i + consts::Re_1]);\n        acc = vec_add(acc, state);\n    }\n    for i in consts::Re_1..consts::Re_1 + consts::Re_2 - 1 {\n        state = non_linear_e(state);\n        state = matrix_e(state);\n        state = vec_add(state, consts::rc_b[i + consts::Ri]);\n        acc = vec_add(acc, state);\n    }\n\n    //one more time but without addition\n    state = non_linear_e(state);\n    state = matrix_e(state);\n    state = vec_add(state, consts::rc_b[consts::Re_1 + consts::Re_2 - 1 + consts::Ri]);\n    (state, acc)\n}\n\n#[field(bn254)]\npub(crate) fn hydra_body_ks(key: [Field; 4], iv: [Field; 4]) -> [Field; 4] {\n    let state = vec_add(key, iv);\n    let mut state = matrix_e(state);\n    for i in 0..consts::Re_1 {\n        state = non_linear_e(state);\n        state = matrix_e(state);\n        state = vec_add(state, consts::rc_b[i]);\n    }\n    for i in 0..consts::Ri {\n        state = non_linear_i(state);\n        state = matrix_i(state, consts::Mi);\n        state = vec_add(state, consts::rc_b[i + consts::Re_1]);\n    }\n    for i in consts::Re_1..consts::Re_1 + consts::Re_2 {\n        state = non_linear_e(state);\n        state = matrix_e(state);\n        state = vec_add(state, consts::rc_b[i + consts::Ri]);\n    }\n    vec_add(state, key)\n}\n\nfn matrix_e<let R: u32>(state: [Field; R]) -> [Field; R] {\n    let sum = state.reduce(|a,b| a + b);\n    let rot_state = rotate_left(state);\n    let mut result = [0; R];\n    for i in 0..R {\n        result[i] = sum + rot_state[i] + state[i] + state[i];\n    }\n    result\n}\n\nfn matrix_i<let R: u32, let L: u32>(state: [Field; R], mat:[[Field; R]; L]) -> [Field; R] {\n    let sum = state.reduce(|a,b| a + b);\n    let mut out = [sum; R];\n    out[0] += state[0] * mat[0][0];\n    for i in 1..R {\n        out[i] += (state[0] * mat[i][0]) + (state[i] * mat[i][i]);\n    }\n    out\n}\n\nfn rotate_left<let R: u32>(mat: [Field; R]) -> [Field; R] {\n    let mut rotated = [0; R];\n    for i in 1..R {\n        rotated[i-1] = mat[i];\n    }\n    rotated[R-1] = mat[0];\n    rotated\n}\n\nfn non_linear_h(roll: [Field; 8]) -> [Field; 8] {\n    let mut dot = roll[0] + roll[1] + roll[2] + roll[3] - roll[4] - roll[5] - roll[6] - roll[7];\n    dot = square(dot);\n    roll.map(|r| r + dot)\n}\n\nfn non_linear_e(state: [Field;4]) -> [Field; 4] {\n    [state[0].pow_32(5), state[1].pow_32(5), state[2].pow_32(5), state[3].pow_32(5)]\n}\n\nfn non_linear_i(state: [Field; 4]) -> [Field;4] {\n    let (dot1, dot2) = get_lm_dot(state);\n    let sum = square(square(dot1) + dot2);\n    [state[0] + sum, state[1] + sum, state[2] + sum, state[3] + sum]\n}\n\nfn non_linear_r(y: [Field;4], z: [Field; 4]) -> ([Field; 4], [Field; 4]) {\n    let (vy, wy) = get_lm_dot(y);\n    let (wz, vz) = get_lm_dot(z);\n    let v = (vy * vz);\n    let w = (wy * wz);\n    (y.map(|yi| yi + v), z.map(|zi| zi + w))\n}\n\nfn get_lm_dot(state: [Field; 4]) -> (Field, Field) {\n    let tmp = state[0] - state[3];\n    (tmp - state[1] + state[2], tmp + state[1] - state[2])\n}\n\nfn square(x: Field) -> Field {\n    x * x\n}\n\nfn vec_concat(lhs:  [Field; 4], rhs: [Field; 4]) -> [Field; 8] {\n    [lhs[0], lhs[1], lhs[2], lhs[3], rhs[0], rhs[1], rhs[2], rhs[3]]\n}\n\nfn vec_split(vec:  [Field; 8]) -> ([Field; 4], [Field; 4]) {\n    ([vec[0], vec[1], vec[2], vec[3]], [vec[4], vec[5], vec[6], vec[7]])\n}\n\nfn vec_add<let R: u32>(lhs: [Field; R], rhs: [Field; R]) -> [Field; R] {\n    let mut result = [0; R];\n    for i in 0..R {\n        result[i] = lhs[i] + rhs[i];\n    }\n    result\n}\n\n#[test]\nfn test_rotate_left() {\n    let test = [0, 1, 2, 3, 4, 5, 6, 7];\n    assert(rotate_left(test) == [1, 2, 3, 4, 5, 6, 7, 0]);\n}\n\n#[test]\nfn test_get_lm_dot() {\n    let (dot1, dot2) = get_lm_dot([17162050878538720375407210140639637720303994375562539862452690421292386592590,\n            11912527370530146728703046717149243981430064476687468213603991691404411193217,\n            18430438893156814166144129663793173051281448131580613239977654404180923080739,\n            7614633435608198927774246011281602559236719354621200488645904294064394220068]);\n    assert(dot1 == 16065328965557188885074047076001964230918658675834484400180448840004504260044);\n    assert(dot2 == 3029505920303854010191881182714106091215891366048194347433123414451480485000);\n}\n\n#[test]\nfn test_non_linear_h() {\n    let state = non_linear_h([17311339206079525542322783825459319113913165622286561296721622612914673407804,\n            16276728151221844182140219810267241649985535582588722449384727866117202327093,\n            10801048258802086965858707507694761799252711922965390030528950861087300763030,\n            3638652786377497073268842010725440468491752112825502524378677961251293024759,\n            7645315248887656730315052486323154491745884763740850513982583264261456826307,\n            10323065323391982836294143162837377995469044206483281154564046348037825339388,\n            20343326181502906791617898953771792194510136932068335746318866730568328752863,\n            17802268834568716074000952286650978346952421838604678848244855399442974823193]);\n    assert(state == [4547325791835956019343387175706495521510639735313024107278926563682326597476,\n        3512714736978274659160823160514418057583009695615185259942031816884855516765,\n        19925277716397792665125716603199213295398550436407887184784458998430762448319,\n        12762882243973202772535851106229891964637590626267999678634186098594754710048,\n        16769544706483362429582061581827605987891723277183347668238091401604918511596,\n        19447294780987688535561152258341829491614882719925778308819554485381287024677,\n        7579312767259337268638502304018968602107611045094798556876170681335981942535,\n        5038255420325146551021555636898154754549895951631141658802159350210628012865]);\n}\n\n#[test]\nfn test_non_linear_i() {\n    let state = non_linear_i([17162050878538720375407210140639637720303994375562539862452690421292386592590,\n            11912527370530146728703046717149243981430064476687468213603991691404411193217,\n            18430438893156814166144129663793173051281448131580613239977654404180923080739,\n            7614633435608198927774246011281602559236719354621200488645904294064394220068]);\n    assert(state == [4309430684818317694633606829961546606191461818288188130026024885465599697736,\n        20948150048649019270175849151728427955865896319829150824875530342153432793980,\n        5577818699436411485370526353115081937168915574306261507550988868354136185885,\n        16650256113727071469247048445860786533672551197762883099917442944813415820831]);\n}\n\n#[test]\nfn test_non_linear_e() {\n    assert(non_linear_e([10, 8, 8, 9]) == [100000, 32768, 32768, 59049]);\n}\n\n#[test]\nfn test_non_linear_r() {\n    let y_in = [17311339206079525542322783825459319113913165622286561296721622612914673407804,\n        16276728151221844182140219810267241649985535582588722449384727866117202327093,\n        10801048258802086965858707507694761799252711922965390030528950861087300763030,\n        3638652786377497073268842010725440468491752112825502524378677961251293024759];\n    let z_in = [7645315248887656730315052486323154491745884763740850513982583264261456826307,\n        10323065323391982836294143162837377995469044206483281154564046348037825339388,\n        20343326181502906791617898953771792194510136932068335746318866730568328752863,\n        17802268834568716074000952286650978346952421838604678848244855399442974823193];\n    let (y_out, z_out) = non_linear_r(y_in, z_in);\n    assert(y_out == [16474558665066990056068011496692118409558256462734362411538742665023636404753,\n        15439947610209308695885447481500040945630626423036523564201847918226165324042,\n        9964267717789551479603935178927561094897802763413191145346070913196263759979,\n        2801872245364961587014069681958239764136842953273303639195798013360256021708]);\n    assert(z_out == [18800231885746230730599298706870897921156360762149932570264867923720730257667,\n        21477981960250556836578389383385121424879520204892363210846331007497098770748,\n        9609999946522205569655739429062260535372248530061383458902947203451793688606,\n        7068942599588014852038792761941446687814533436597726560828935872326439758936]);\n}\n\n#[test]\nfn test_matrix_e() {\n    assert(matrix_e([2, 1, 1, 1]) == [10, 8, 8, 9]);\n}\n","path":"/home/drone/projects/rione/circuits/lib/noir-hydra/src/bn254/ks.nr"},"114":{"source":"\r\nuse std::runtime::is_unconstrained;\r\nuse std::hash::keccak::keccakf1600;\r\n\r\nglobal BLOCK_SIZE_IN_BYTES: u32 = 136; //(1600 - BITS * 2) / WORD_SIZE;\r\nglobal WORD_SIZE: u32 = 8; // Limbs are made up of u64s so 8 bytes each.\r\nglobal LIMBS_PER_BLOCK: u32 = BLOCK_SIZE_IN_BYTES / WORD_SIZE;\r\nglobal NUM_KECCAK_LANES: u32 = 25;\r\n\r\n#[no_predicates]\r\npub fn keccak256<let N: u32>(input: [u8; N], message_size: u32) -> [u8; 32] {\r\n    assert(N >= message_size);\r\n\r\n    // Copy input to block bytes. For that we'll need at least input bytes (N)\r\n    // but we want it to be padded to a multiple of BLOCK_SIZE_IN_BYTES.\r\n    let mut block_bytes = [0; ((N / BLOCK_SIZE_IN_BYTES) + 1) * BLOCK_SIZE_IN_BYTES];\r\n    if is_unconstrained() {\r\n        for i in 0..message_size {\r\n            block_bytes[i] = input[i];\r\n        }\r\n    } else {\r\n        for i in 0..N {\r\n            if i < message_size {\r\n                block_bytes[i] = input[i];\r\n            }\r\n        }\r\n    }\r\n\r\n    //1. format_input_lanes\r\n    let max_blocks = (N + BLOCK_SIZE_IN_BYTES) / BLOCK_SIZE_IN_BYTES;\r\n    //maximum number of bytes to hash\r\n    let real_max_blocks = (message_size + BLOCK_SIZE_IN_BYTES) / BLOCK_SIZE_IN_BYTES;\r\n    let real_blocks_bytes = real_max_blocks * BLOCK_SIZE_IN_BYTES;\r\n\r\n    block_bytes[message_size] = 1;\r\n    block_bytes[real_blocks_bytes - 1] = 0x80;\r\n\r\n    // populate a vector of 64-bit limbs from our byte array\r\n    let mut sliced_buffer =\r\n        [0; (((N / BLOCK_SIZE_IN_BYTES) + 1) * BLOCK_SIZE_IN_BYTES) / WORD_SIZE];\r\n    for i in 0..sliced_buffer.len() {\r\n        let limb_start = WORD_SIZE * i;\r\n\r\n        let mut sliced = 0;\r\n        let mut v = 1;\r\n        for k in 0..WORD_SIZE {\r\n            sliced += v * (block_bytes[limb_start + k] as Field);\r\n            v *= 256;\r\n        }\r\n\r\n        sliced_buffer[i] = sliced as u64;\r\n    }\r\n\r\n    //2. sponge_absorb\r\n    let mut state: [u64; NUM_KECCAK_LANES] = [0; NUM_KECCAK_LANES];\r\n    // When in an unconstrained runtime we can take advantage of runtime loop bounds,\r\n    // thus allowing us to simplify the loop body.\r\n    if is_unconstrained() {\r\n        for i in 0..real_max_blocks {\r\n            if (i == 0) {\r\n                for j in 0..LIMBS_PER_BLOCK {\r\n                    state[j] = sliced_buffer[j];\r\n                }\r\n            } else {\r\n                for j in 0..LIMBS_PER_BLOCK {\r\n                    state[j] = state[j] ^ sliced_buffer[i * LIMBS_PER_BLOCK + j];\r\n                }\r\n            }\r\n            state = keccakf1600(state);\r\n        }\r\n    } else {\r\n        // `real_max_blocks` is guaranteed to at least be `1`\r\n        // We peel out the first block as to avoid a conditional inside of the loop.\r\n        // Otherwise, a dynamic predicate can cause a blowup in a constrained runtime.\r\n        for j in 0..LIMBS_PER_BLOCK {\r\n            state[j] = sliced_buffer[j];\r\n        }\r\n        state = keccakf1600(state);\r\n        for i in 1..max_blocks {\r\n            if i < real_max_blocks {\r\n                for j in 0..LIMBS_PER_BLOCK {\r\n                    state[j] = state[j] ^ sliced_buffer[i * LIMBS_PER_BLOCK + j];\r\n                }\r\n                state = keccakf1600(state);\r\n            }\r\n        }\r\n    }\r\n\r\n    //3. sponge_squeeze\r\n    let mut result = [0; 32];\r\n    for i in 0..4 {\r\n        let lane = state[i] as Field;\r\n        let lane_le: [u8; 8] = lane.to_le_bytes();\r\n        for j in 0..8 {\r\n            result[8 * i + j] = lane_le[j];\r\n        }\r\n    }\r\n    result\r\n}","path":"/home/drone/projects/rione/circuits/lib/keccak256/src/keccak256.nr"}},"names":["main"],"brillig_names":["u64_to_ascii_bytes","get_account_with_storage","directive_invert","directive_integer_quotient","directive_to_radix"]}